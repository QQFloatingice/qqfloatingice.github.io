{"posts":[{"title":"227第250天纪念日的一些随想","content":"227已经过去250天了 在这250天里，我对当时的一些行为做了一些反思，发现其实我们的一些言论并不是理性的，我们不应该因为xz的脑残粉去无脑黑xz，为黑而黑也没什么意义，当然xz的无所作为是加剧了事态的严重性，导致xz脑残粉“【你们欺负肖战哥哥，我们就让整个平台爆炸】【除了lofter，AO3还有什么平台，你们说一个我们封一个】【如何举报lof步骤详解】”的行为的出现，导致我们的部分平台被bang。。。当时仔细想来，问题的本院还是在NC粉问题上。 在这250天里，我大概是接触了不少于50位xz粉，大部分其实都还是正常的【以至于我自爆身份的时候对我反应还不是很大（笑，我还是太年轻。。。 只有少部分害群之马表现的和个ZZ一样于是就出现了以下言论“谁会喜欢一个227”；“TA被针对是活该”对于这种NC粉，我只想说：”宁，配吗？“ 关于NC粉这个问题，据说一直是某圈的必然问题，这件事不在xz身上爆发也迟早会在别人身上爆发，所以，虽然但是，我们其实都是受害者。。。 在这里，我对这250天里我再传的部分不良影响，以及那些被我误喷的人们道歉，也感谢部分xz粉丝对我的包容。 此外，在这里，我还要对部分某圈人做一个提醒：“不要把那些ex的东西放出来了，搞臭一个圈够了，核都有不扩撒条约，你们也应该有个NC不扩撒条约吧。。。” （这第250天纪念日把我也整的有点250，写的有点乱，将就着看吧 P.s. 关于某圈的危害 ","link":"https://qqfloatingice.github.io/post/227-di-250-tian-ji-nian-ri-de-yi-xie-sui-xiang/"},{"title":"QQ foating ice","content":"关于本站 为何建立 寒假期间因为一只蝙蝠。。。。。。我在家上网课摸鱼的时候因为比较闲，就把我曾经因为时间和精力等原因关停的动态博客重开（苦逼未成年学生党的悲哀），本站托管在gitpage上，由Gridea强力驱动，目前本站主页已被各大主流搜索引擎收录dog.jpg 关于博主 年龄与教育经历 出生于2005年9月前，关于我的年龄与级端有兴趣可以自己算一下。。。 爱好&amp;技能 博主是个奇奇怪怪的人，爱好运动与宅家，这里放几个数据吧 1km最佳成绩：2'58&quot; 5km最佳成绩：22'29&quot; 10km最佳成绩：50&quot;28 半马最佳成绩：1h 48m 31s 全马最佳成绩：4h 01m 14s 曾经在8个小时内从上海骑单车到高铁2h行程时间的某城市 曾经在家出上课外4年没出过门 目前博主在建站方面有一定经验，稍会板绘、PS、剪辑、影视后期，ous！轻度玩家（刚入键鼠流），Mc1.7.10遗民，Golang学习中， C#，C＋＋ 都位于遗忘的边缘，前端基本狗屁不通。 . 如何联系博主 邮箱 qqfloatingice.gmail.com 1449548774@qq.com l482949498@qq.com 2716314359@qq.com 1640800953@qq.com 654704772@qq.com QQ 1449548774 482949498 2716314359 1640800953 654704772 微信 qqfloatingice 推特 https://twitter.com/tyx94219678 微博 QQfloatingice 小破站 QQ-Floating-Ice 随机图（来自Sora） 百合向 本文经9次修改，目前定稿与 2020年9月8日8时58分53秒，第四节晚自习上课时。 By 正在摸鱼的QQ Floating Ice ","link":"https://qqfloatingice.github.io/post/2/"},{"title":"wallace-toolbox新版汉化","content":"版本号 wallace-toolbox-0.0.6（截图懒得换了 下载地址 0.0.5 0.0.6 更新说明 0.0.6 1.增加了移除所以的预装APP功能 0.0.5 1.增加了更改WiFi/l蓝牙 MAC地址功能 2.没了 3.。。。 本人是个英语学渣，汉化如有错误请多多包函 ","link":"https://qqfloatingice.github.io/post/wallace-toolbox-xin-ban-han-hua/"},{"title":"关于4代魔改无限拉倍频的一些杂谈","content":"超频有风险，魔改需谨慎，本人不对本内容产生的问题承担任何责任 写在前面： 如果系统有mcupdate_genuineintel.dll 都要删除了 才能拉倍频 对于核显为 hd4600的魔改u暂时还没发现有在非笔记本平台上拉倍频成功过的，如果有的话，最好留个言，所以建议大家如果想拉倍频，最好还是上5200核显的魔改 最近看到国外有大神干了4代魔改即 i7-4xxxxmq改台式机封装的帖子这里做个翻译已即我亲自实践的一些体会，原帖地址 这个外国教程的大致思路为两步： 第一：删除306c3微码 第二：用Throttlestop这个软件进行一堆骚操作 第一个这个删除微码的步骤其实并不是每种CPU都需要，现在4代魔改大致分为两种CPU，分别是306c3（4600核显） 和30661（5200核显） ，基本上所有的主板都没有30661（5200核显）的微码，所以如果用5200核显的cpu的可以不用改bios就无限拉倍频 删除微码我是利用UBU工具对bios微码进行删除 删除完的话一般都会剩下306c2的微码 这是删除前的 这是删除后： 然后第二大步就是要用Throttlestop来进行一堆骚操作了 首先当然是先下载Throttlestop拉 这个比较好找就自己下载吧 然后打开，点开里面的FIVR选项框 首先先看这个框里面的是不是+0，如果是+0是不能拉倍频的了，只能考虑Z87 Z97拉外频了 然后重点来了！！！！！ 将4 Cores Active 先拉到最大，然后点ok退出，再重新点开FIVR,你就会发现Overclock后面的数字会跟着你turbo overclocking的数字+大了，例如下图是+2，每次你点这个最大可设置的倍频数都会变大2，想最大是多少，点多几次就行了 然后就是最后一部步，回到主界面勾选set multipler 设置到自己想设置的频率，点击turn on（点完会变turn off）这样就设置成功了 当然你们设置的倍频要有足够电压~电压也可以用这个软件里面的FIVR里面的选项来设置 http://valid.x86.fr/6n50n4 这个就是我拉的4750hq 。。。。这U肯定是同一晶圆的边角料。。。太雷了1.41v上4.4g都不是特别稳 上面就是无限拉的基本操作了 同理，缓存频率也是可以无限拉的，只是藏得比较深，在FIVR设置里面 ps：灰色是因为我暂时手套上这台机不是用的4代魔改=。= 4代魔改这玩意主要是调用AVX(fpu)会特别热，功耗特别大 如果不调用AVX，像我电压上到1.41v上了液态金属后，还是能压在85度以内的（散热赤兔马） 所以核心问题在AVX上， 然后我们就可以利用功耗墙来对其限制，Throttlestop也提供了功耗墙的设置，我的设置是长功耗75W，正常不调用AVX的时候一般会小于85w，这个值就根据自己的散热来调整了。 设置功耗墙在首页的TPL 然后设置里面的长功耗和短功耗，可以设置短功耗保持多少秒变长功耗限制 ","link":"https://qqfloatingice.github.io/post/guan-yu-4-dai-mo-gai-wu-xian-la-bei-pin-de-yi-xie-za-tan/"},{"title":"佳明645一周体验感受","content":"前排提示，这是一个迟到很久的体验博客，这块表好像是去年这个时候到手的吧。。。 因为最近开学了，然鹅我们学校并不能带手机，那么我本来用的iwatch就基本残废了，所以，我就打算换一块对手机依然性没那么高的手手表，本来先买块谷歌的智能表的，但是想想手上没钱，就去翻了下我的柜子，就翻到了这块奇奇怪怪的，吃灰一年多的，不知道谁给我的（也可能是我脑抽的时候买的）这块佳明645. p.s.还翻到了一台吃灰更久的switch日版。。。（鬼知道我柜子里有什么 然后这块表的具体参数是这样的： 设备尺寸 42.5 x 42.5 x 13.5 mm 重量 41.8克 防水等级1 5ATM 表带尺寸 20mm 屏幕尺寸 1.2&quot; (30.4 mm) 屏幕分辨率 240x240像素，强光下可见半透式反射屏 电池续航 手表模式: 7天 GPS模式: 14小时 连接方式 Bluetooth®, ANT+®, Wi-Fi® 剩下的自己去官网看吧 外观是这样的： 没错，只有一张图。。。 哦，对了这个表好像还有个版本是支持音乐播放的，我这个不支持。 然后我说下自己的感受 一个字：轻！！！ 这块表的佩戴感受总体来说较我的iwatch来说更加优秀，底部无突起的设计真的是赞了。对于一块本身就是运动表定位的表来说，各类传感器也不比不比iwatch差，而且日常使用的续航也比iwatch长不少。 不过这个表的缺点也不少 1.没有触控（但是和佳明的几个资深用户讨论过后，他们觉得佳明的触控并不好用，这样的3+2的布局更好用） 2.日用功能单一（不过在运动检测方面还是功能挺丰富的） 3.太过扎心，让我清楚的明白如果我不是出去运动什么的日子，步数不超过1000.。。 总结 没有总结（如果有的话，那就是，以后我要多翻翻柜子，还有，为什么switch现在怎么贵，我日版的增强续航版挂3300都有人买。。。） p.s.：真正原因，我不会写总结。。。。 更详细的解释在这里 对比测评在这里 ","link":"https://qqfloatingice.github.io/post/jia-ming-645-yi-zhou-ti-yan-gan-shou/"},{"title":"关于我又一个哥哥出国留学的事","content":"又双叒叕出去一个 随便证明一下我还活着 ","link":"https://qqfloatingice.github.io/post/guan-yu-wo-you-yi-ge-ge-ge-chu-guo-liu-xue-de-shi/"},{"title":"如何在kaios原生系统内使用自带表情","content":"本教程所提及内容可能对你的kaios设备造成伤害，博主与本站不对所造成的伤害负责 因为本人英语翻译水平有限有能力的读者可以自行查看原文内容（404网站警告 本教程理论上不会影响kaios设备的OTA更新，一切修改将在重置或者OTA更新后恢复 1，下载这个.zip文件（原文作者仅修修复了键盘速度与添加了来自GerdaOS dumps的APP） 2，使用临时root通过ADB工具将应用程序推送入数据分区中的/ data / local / webapps中 adb push keyboard.gaiamobile.org /data/local/webapps 3，获取webapps.json文件 adb pull /data/local/webapps/webapps.json 4，更改键盘gaiamobile.org应用程序 &quot;basePath&quot;: &quot;/system/b2g/webapps&quot; 改为 &quot;basePath&quot;: &quot;/data/local/webapps&quot;, 5，进行此更改后，将webapps.json文件压入其位置并重新启动手机： adb push webapps.json /data/local/webapps/ adb reboot ","link":"https://qqfloatingice.github.io/post/ru-he-zai-kaios-yuan-sheng-xi-tong-nei-shi-yong-zi-dai-biao-qing/"},{"title":"常用软件推荐","content":"本文仅代表个人观点，不喜勿喷 由于现在国内的软件环境，流氓软件层出不穷，这里整理了一些还算良心的软件，足够日常使用。 如果在百度的各种软件站下载，请不要用高速下载 压缩，解压缩 7-zip File Manager 杀毒软件 1.win10自带 2.卡巴斯基 弹窗拦截 sorry，如果没有流氓软件不需要，真想用联想自带不错 浏览器 1.Firefox Developer Edition 2.Chrome 3.Microsoft Edge 常用工具 图吧工具箱2020 utools OfficeBox 桌面整理 DeskGo（不要下全家桶） 聊天工具 TIM QQ for Windows10（Windows10 UWP） 网盘 1.~ 谷歌云盘~ (能不能用请遵循地方法律) 2.OneDrive 3.超星云盘 截图 1.Snipaste 2win10自带 BT下载 1，uTorrentPortable，下载地址 如有补充请在下方评论栏指出 ","link":"https://qqfloatingice.github.io/post/chang-yong-ruan-jian-tui-jian/"},{"title":"【噩耗】本站回迁失败","content":"由于某些特殊原因，我的个人境外服务器可能永久失效，本来想吧域名换过来的，但是这个二级域名已经被各大搜索引擎收录（我本来的域名都没有被百度收录。。。）所以，本站在往后三年内可能不会回迁（换成动态站倒是有可能）就是这样了。。。 希望Gitpage能撑下去。。。 ","link":"https://qqfloatingice.github.io/post/e-hao-ben-zhan-hui-qian-shi-bai/"},{"title":"迷你键盘杂谈","content":"其实，也没什么好谈的，就是我换了个为了更好的用触控板，更好的码字，换了个61键的小键盘，把我原来贼船的黑轴变成游戏专用而已。。。如果你有兴趣，请往下读。。。。 其实，我烦那个贼船的黑轴有一段时间了，由于某些原因，我码字的量有较大增加，然后，就经常敲字敲敲码敲打手疼（不过打游戏倒是挺香的）因为后来开学之后回到学校这边住，主机没带过来，一直用二奶E490和一台2017年的X1 yoga也就没怎么管这件事。 后来，我因为用了半年的触控板，感觉被触控板绑架了，买了个秒控板来，然后因为对笔记本键盘的适应，我有种强烈的愿望想把触控板放在空格底下，然后因为我那块贼船太长，就很别扭，于是打算换个小键盘。。。。 最开始我想到的是TP的薄膜键盘 因为下边框的问题，买了看了下就退了。。。 然后我有看了下TP的其他键盘，感觉2525周年纪念的海星，但是。。。限量发售，现在早就没了，买二手，又贵又。。。。。而且青轴我也受不了（太tm吵 然后最后我只能看看tb，然后给我推了这玩意 看看外观和键帽还不错，还有个双模，只是轴体。。。 凯华还算过得去，但是买回来肯定要自己润滑，而且，回车，空格那几个大键肯定自己换别的颜色轴体。。。 所以我最后买了这个，不过价格还算合理，手感。。。慢慢看玄学吧。。。 ps.快递已经到了，我懒得拿，明天再说 2020/8/7更新 好了，拿回来敲了一下，然后就润轴换轴，润完换完手感感觉海星，就是有一点必须吐槽，这键盘吗，没有delete！！！这个问题我目前还没法解决，要么等驱动更新（基本不可能）要么有空折腾下。。。 好吧，我吐槽错了，不过键帽也有锅，delete是fn+backspace键。。。 ","link":"https://qqfloatingice.github.io/post/mi-ni-jian-pan-za-tan/"},{"title":"【喜讯】本辣鸡博客已被各大搜索引擎收录","content":"百度能收录我是真的没想到。。。 ","link":"https://qqfloatingice.github.io/post/xi-xun-ben-la-ji-bo-ke-yi-bei-ge-da-sou-suo-yin-qing-shou-lu/"},{"title":"经典P4大赏","content":"等了好几天的快递，最后一块P4（唯一支持64位的P4）到了，终于又可以水一篇了（手动滑稽） P4 EE（130微米）我用的最久的一块 三缓容量瞩目 游戏机上的P4HT 没有特点 64位的P4（安腾落泪） 基本没用（性能问题）超冒烟都没用但是装个win7-X86-amd64精简还是香的（感谢liaronce提供的精简镜像） 至少有B格 ","link":"https://qqfloatingice.github.io/post/jing-dian-p4-da-shang/"},{"title":"【转载】一些kaios教程","content":"以下内容均转载自inSoraSky 【2020年7月】Nokia 8110 4G GerdaOS刷机教程 【清水博客汉化】OmniSD（本教程中的此教程地址为https://qqfloatingice.github.io/post/k8） 【清水博客汉化】reader by wolfff78 【清水博客汉化】Wallace Toolbox——折腾kaiOS手机的全能APP 【软件分享】KaiBoy汉化版 【转载】把掰直的香蕉掰回去——8110恢复原厂系统教程 8110 V16系统root方法 8110恢复官方系统 kaiOS相关的网站推荐 Nokia 8110 4G 拨号盘神秘代码 OneKeyOmniSD - 一键安装OmniSD root你的香蕉机 第三方8110 kaiOS刷机包：V12+UK 如何让8110的终端CLI程序解析域名 如何让香蕉开车开的更快——Nokia 8110 4G 提速小技巧 色彩斑斓的Recovery - Philz Touch Recovery（只适用于Nokia 8110 4G） 适用于Nokia 8110 4G(KaiOS)的app 修改8110的开机第一屏 p.s.我比较懒，没把图全发在图床上，以上教程的图可能会404在这里说声抱歉 ","link":"https://qqfloatingice.github.io/post/zhuan-zai-yi-xie-kaios-jiao-cheng/"},{"title":"啊，这！","content":" ","link":"https://qqfloatingice.github.io/post/a-zhe/"},{"title":"高考加油","content":"祝群主&amp;博主&amp;吧主Sora以及群管钾肥猫高考加油 以及2020年高考的考生高考加油 p.s.我知道今天害有点早。。。 对了要高考的同学请记得带准考证、身份证、2b铅笔、橡皮、直尺、三角板、量角器、圆规、0.5中性笔、垫板、矿泉水。如果第一个出考场被采访的话麻烦问一句Gridea什么时候提供arm64的支持，GerdaOS什么时候才能用上量子火狐，mirai什么时候能控制天气，windowsphone什么时候起死复生以及termux什么时候更新 ","link":"https://qqfloatingice.github.io/post/gao-kao-jia-you/"},{"title":"关于30.对初中毕业以及中考的想法","content":"题文无关 &lt;!-- more --&gt; 我是一个心思很重的人。内心想法很多，所以这几天宅在家里无所事事也想了许多，到中考的那一天我才明白就这样一张破纸就能把我们各分东西，我内心常感叹这世界的不公，总有人的成绩好有的人差凭什么这样把人三六九等的分成不同的区域，成绩差的人不见得品质就差，他们多数是有一颗善良的心的，他们不是差生 只是成绩落后 我和所谓的差生做过前后桌 我发现自己对差生的理解出了偏差 他们不坏 他常常会帮助我 帮助我解决一些不是学习上的问题，比如怎么也去不掉的胶水 找不到了的书本等等，我能从他身上感受到同学间的互帮互助（虽然他很吵，我们也经常会吵架，但我觉得他给我的感受就是本质不坏，人还不错）我时常在想老师教书育人的目的究竟是什么？是为了那一纸的升学率，还是为了培养孩子的品质？这个答案不得而知，我也无法改变什么，初中三年真的很短很短，短到好像就是一瞬，但这一瞬包含了所有的开心 难过 遗憾 委屈（委屈这件事真的不能忍，它不会像开心 难过一样随着时间消逝，它会埋在心里 随着你的成长慢慢开花结果长成一棵奇形怪状的树 内心的也会变成善妒的模样 变得不像自己了 我建议有委屈一定要当下解决）它像一个万花筒折射出了我的青春 我的三年.就像历史书上的五年计划一样 我们的人生被分成了一段一段的旅程，初中三年这一程算是到站了！30.会带着对你们的思念开启下一段征程！愿我们再见面时都是更好的自己！！！ 走过了危机四伏的青春 我们每个人都是幸存者.毕业快乐🎓 最后说一遍我们的口号吧！ 三 二 一 我是南中学生 要为南中争光！ ","link":"https://qqfloatingice.github.io/post/guan-yu-30dui-chu-zhong-bi-ye-yi-ji-zhong-kao-de-xiang-fa/"},{"title":"博客年中总结","content":"更没什么好说的看图。。。 好像有点要说，本博客在这半年改变还是很大的（包括统计方式） 所以统计分成了两个 谷歌统计 百度统计 ","link":"https://qqfloatingice.github.io/post/bo-ke-nian-zhong-zong-jie/"},{"title":"个人年中总结","content":"没什么好总结的，看上图 ","link":"https://qqfloatingice.github.io/post/ge-ren-nian-zhong-zong-jie/"},{"title":"win使用iPad随航","content":"据我用mac的经验而言随航还是很有用的但是我并不是一直有mac的（mbp是我妈在用。。。） 这里建议使用XDisplay因为它免费所以。。。其实随航的工具有很多但是好用的免费版很少 。这个倒是海星，只是支持触屏但是帧率比较低。而且只要USB连接就行。。。 下载地址 官网 所需工具 1.IOS12一下的苹果设备 2.苹果原装数据线 3.电脑一台win和Linux均可 方法自行百度 ","link":"https://qqfloatingice.github.io/post/win-shi-yong-ipad-sui-hang/"},{"title":"在安卓手机上安装Ubuntu详细教程","content":"教程要点：1.小白慎用,2安装有风险，出了问题与本文无关 准备材料： 1.安卓手机一部（Android 7.0+） 2.Termux应用程序（不root） 3.F-Droid.apk安装包（不翻墙）（可选） 安装步骤： 1、 下载Termux： 法一：从F-Droid中下载和安装Termux 1、 安装F-Droid： 打开官网地址：https://f-droid.org/（如图1所示）选择下载F-Droid。 同时在官网的右侧搜索框中搜索Termux，选择 “Termux 带有软件包的终端模拟器”，记下网页地址https://f-droid.org/zh_Hans/packages/com.termux/ 安装F-Droid.apk。 安装完成后，在F-Droid的app界面中选择 设置-&gt;软件源，如下图所示： 在弹出的菜单中点击右上角的“+”号，添加新的软件源，将刚才在F-Droid官网中搜索Termux得到的网址https://f-droid.org/zh_Hans/packages/com.termux/填入软件源地址中，指纹（可选）可以不用填写，点击添加。完成后如下图所示，将该软件源选择开启。 2、 下载Termux： 切换回Fdriod的主页，选择 最新 菜单页，点击搜索按钮，如下图所示： 与在Fdriod主页搜索Termux同理，搜索Termux，选择“Termux 带有软件包的终端模拟器”，点击下载。 下载时间会比较久（无需梯子，亲测4G网络下载没有问题），请耐心等待（如果没有下载完成请重新下载，Fdriod会继续下载）。 3、 安装Termux： Termux下载完成后如下图所示，选择安装（安装过程中请选择允许访问存储器）。 法二：（推荐） 某不限速网盘下载：链接: http://pan-yz.chaoxing.com/share/info/77a22b10447a44e1 提取码 : 65kteu （法一的下载时间都较慢，推荐通过网盘下载） 2、 安装Termux Termux下载完成后选择安装（安装过程中请选择允许访问存储器）。安装完成后会出现如下图所示的欢迎界面。 ３、 配置Termux 修改安装源： 由于官方源下载速度较慢，建议将安装源修改为国内源。修改方法如下：在Termux主菜单提示符$后面输入： $ vi $PREFIX/etc/apt/sources.list 在弹出的文件中输入i（vi的插入），输入#，即将deb https://termux.org/packages/ stable main https://termux.org/packages/ stable main注释起来，随后在下一行输入：deb http://mirrors.tuna.tsinghua.edu.cn/termux stable main 即将安装源修改为 http://mirrors.tuna.tsinghua.edu.cn/termux（不要加 [arch=all,i686] ，加了会出现gcc、gdb等无法下载的情况），保存退出（按Esc，进入命令模式，输入 ：wq）。 4、在Termux上安装 Ubuntu Termux 支持安装其它 Linux 发行版。本文以Ubuntu为例，详述安装在Termux上安装 Ubuntu的具体步骤如下： 获取和更新软件包： Termux上的安装软件包的命令是apt和pkg 命令，pkg命令在运行前会执行一次apt update（# 连接远程仓库，获取软件包信息），保证安装的包是最新版本。 $ apt-get update 2.更新软件包： 输入命令apt upgrade（#更新本地已经安装的软件包） $ apt-get upgrade -y 第一次安装需要10分钟左右，此后再upgrade速度就很快 5、 安装proot软件包 安装wget、proot和git：（30分钟左右） $ apt-get install wget proot git -y 测试：proot $ termux-chroot 注意：如果未能实现chroot，请重新输入apt-get install proot –y，如果termux-chroot命令依然不能使用，请参照本文F-Droid中安装Termux 的方法来重新安装Termux（因为手机没有root，可能有的手机会不支持root，因此可以通过F-Droid来解决这个问题）。 proot允许未root的手机模拟管理员用户在这个proot环境下面,相当于是进入了home目录,可以很方便地进行一些配置。如图所示，root和非root环境下的当前工作目录是不一样的。 注：在管理员身份下，可以通过输入exit可回到普通用户身份。 6、访问手机存储目录 访问手机存储目录需要先请求权限，执行以下命令： $termux-setup-storage 执行命令后，手机会弹框询问是否授权，&quot;始终允许&quot;即可。 授权后会在家目录下生成 storage 子目录。其中包含很多软链接文件，指向手机实际的存储目录。 7、到Git上克隆ubuntu-in-termux Git地址：https://github.com/MFDGaming/ubuntu-in-termux.git 输入以下命令： $ cd ~ $ git clone https://github.com/MFDGaming/ubuntu-in-termux.git 第一次安装需5分钟左右，再次安装会出现已经有ubuntu-in-termux目录的提示，无需重复安装。 获取成功后，可以看到在当前目录下生成了一个ubuntu-in-termux目录，进入ubuntu-in-termux目录： cd ubuntu-in-termux 1s可以看到目录下有一个README.md说明文档， cat README.md 查看说明文档里面的内容，则可以看到如下的安装步骤说明，从中可以看出，本文的说明步骤与其一致。 Installation steps Update termux: apt-get update &amp;&amp; apt-get upgrade -y Install wget: apt-get install wget -y Install proot: apt-get install proot -y Install git: apt-get install git -y Go to HOME folder: cd ~ Download script: git clone https://github.com/MFDGaming/ubuntu-in-termux.git Go to script folder: cd ubuntu-in-termux Give execution permission: chmod +x ubuntu.sh Run the script: ./ubuntu.sh -y Now just start ubuntu: ./startubuntu.sh 8、安装Ubuntu 添加ubuntu.sh的执行权限，然后运行ubuntu.sh脚本来安装ubuntu： $ chmod +x ubuntu.sh $ ./ubuntu.sh –y 安装需要几个小时，过程中手机可以运行其他应用，但请注意不要关闭Termux的后台运行程序。 9、启动Ubuntu 安装后可以看到提示启动Ubuntu的方式为运行startubuntu.sh脚本： ./startubuntu.sh 运行脚本后可以看到此时已经进入了Ubuntu系统，提示符发生了改变，这时候的提示符与我们在桌面版Ubuntu上看到的是一样的，说明我们已经成功安装了Ubuntu。 查看安装的Ubuntu版本： $ cat /etc/issue Ubuntu 19.04 \\n \\1 以后要在Termux上运行ubuntu都是cd ubuntu-in-termux进入安装目录，执行./startubuntu.sh启动脚本。退出的方式为输入exit。 至于我参考了什么，这好像是前人指导完成的，具体是谁，我记不清了。。。这仅仅是个教程整理，有谁如果指导过我可以在评论区发言。。。 ","link":"https://qqfloatingice.github.io/post/zai-an-zhuo-shou-ji-shang-an-zhuang-ubuntu-xiang-xi-jiao-cheng/"},{"title":"中考加油","content":"祝自己与2017届所有浙江学生 中考加油 愿我们都能考上理想的高中！！！！ p.s.我能不要脸的求个祝福吗？ ","link":"https://qqfloatingice.github.io/post/zhong-kao-jia-you/"},{"title":"【教程】旧电脑安装FreeNAS 11","content":"必备工具 （1）一台可以安装FreeNAS的硬件设备，本人准备使用一台旧的笔记本（联想 u410)。 （2）官方镜像，可以在FreeNAS官网下载。这里我可能以后会加上自己的源 （3）U盘一个，硬盘两个，由于FreeNAS安装在一整块磁盘上，如果安装在一块硬盘上就没能存储数据，所以一个硬盘作为系统盘，一个刻录安装镜像。系统盘最好大于8G。 （4）win32diskimager刻录软件。 安装步骤 1.刻录系统安装U盘。安装win32diskimager，打开下载好的FreeNAS镜像。插入优盘设备选择优盘，点击写入，等待写入完成。安装U盘就做好了。 2.进入BIOS，将安装U盘和插入准备安装FreeNAS的设备，插入一个键盘，开机按F12（不同的主板按键不同）进入BIOS，选择刻录的U盘启动。 3.进入安装程序，标志性的图标出现根据提示按Enter键。 选择install/upgrade点确定键。 选择作为系统盘的硬盘，空格选择，enter确认。这里建议选择16G以上SSD。 一些警告，确认进入下一步。 为FreeNAS设置一个密码。 选择Boot模式，不同主板模式不同，支持UEFI的选择UEFI模式。 开始安装。 安装成功后，拔掉安装U盘，重启。 显示一些配置信息。最小面有webUI的局域网地址（在插入网线的情况下）。 登录系统 在浏览器中输入局域网IP地址。用户名输入root，密码是安装时候设置的密码。 接下来就是存储空间和用户的创建，FreeNAS的功能很多，有待以后发掘。搭建家庭影音中心Plex也是不错的，还可以搭建家庭私有云nextcoud。 使用教程有空我会写一份，以后在这里传送 p.s.我自己安装的时候忘了拍照了，所以，图片来源于网络。。。。 关于连接手机的问题，这里建议ES 文件浏览器 ","link":"https://qqfloatingice.github.io/post/jiao-cheng-jiu-dian-nao-an-zhuang-freenas-11/"},{"title":"【教程】如何白嫖google sites，搭建主页","content":"首先，进入官网 上网有问题的请自己寻找谷歌访问的方法。。。 点击+号 进入编辑页面 按喜好设定 所有更改将放在云端，不用担心换电脑导致的数据丢失。。 ","link":"https://qqfloatingice.github.io/post/jiao-cheng-ru-he-bai-piao-google-sitesda-jian-zhu-ye/"},{"title":"明天就要直升班考试了，能求个祝福吗","content":"明天就要直升班考试了，能求个祝福吗（在评论区打出考试加油即可） ","link":"https://qqfloatingice.github.io/post/ming-tian-jiu-yao-zhi-sheng-ban-kao-shi-liao-neng-qiu-ge-zhu-fu-ma/"},{"title":"关于本博客头像的说明","content":"本博客接入世界最大的头像库Garvatar，如果需要更改博客中的头像，请前往Garvatar官网（http://cn.gravatar.com/）注册账号修改在Garvatar上的头像，然后使用Garvatar账号绑定的邮箱在本博客留言。 ","link":"https://qqfloatingice.github.io/post/ba/"},{"title":"几何画板的替代品","content":"我是在写作业的时候发现这个网页的，所以内容以后补（可能也不会补）这里直接上链接 桌面版直链 不完整版 完整版 原下载源太慢。。。 ","link":"https://qqfloatingice.github.io/post/ji-he-hua-ban-de-ti-dai-pin/"},{"title":"初学golang实现杨辉三角","content":"。。。 为了维护光荣传统，我要把第二个go程序写成杨辉三角。。。。。 package main; import ( &quot;fmt&quot; ); const LINES int = 100;//设定杨辉三角10行，同时也相当于10列 func ShowYanghui(){ var yh [LINES][LINES]int; for i := 0; i &lt; LINES; i++ { for j := 0; j &lt; i + 1; j++ { if i &lt; 2 {//两行以内三角中的数字都是1 yh[i][j] = 1; }else{//第三行开始，正式计算数值写入数组 if j == 0 || j == i { yh[i][j] = 1;//所有行的第一列和最后一列都是1 }else{ yh[i][j] = yh[i-1][j-1] + yh[i-1][j];//当前数组元素是上一行的前一个元素加上上一行的当前列元素 } } fmt.Printf(&quot;%d\\t&quot;, yh[i][j] );//格式化输出一行 } fmt.Print(&quot;\\n&quot;);//换行 } } func main(){ ShowYanghui(); }; U1S1，GOLANG的运行效率好像真的不如C++。。。。。。 ","link":"https://qqfloatingice.github.io/post/g0/"},{"title":"关于Gerda OS","content":"把香蕉“掰直”：Nokia 8110 4G 刷入GerdaOS 链接 GerdaOS 功能演示 链接 ","link":"https://qqfloatingice.github.io/post/d1/"},{"title":"本博客已和百度达成合作（滑稽）","content":"<!DOCTYPE html> 源码 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--需求：把百度搜索框内嵌到自己的网页中--&gt; &lt;!--解决方案分析--&gt; &lt;!--input type=&quot;text&quot; 表示是一个输入框--&gt; &lt;!--input type=&quot;submit&quot; 表示一个提交按钮 相当于一个开关告诉form要发送数据--&gt; &lt;form action=&quot;https://www.baidu.com/s&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;wd&quot;/&gt;&lt;input type=&quot;submit&quot; value=&quot;百度一下&quot;/&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; ","link":"https://qqfloatingice.github.io/post/ben-bo-ke-yi-he-bai-du-da-cheng-he-zuo-hua-ji/"},{"title":"视频测试","content":" ","link":"https://qqfloatingice.github.io/post/c5/"},{"title":"首次实现硬核无损改装笔记本支持服务器U.2硬盘","content":"蓝天P570WM移动工作站准系统笔记本，X79芯片组，12核心处理器，双显卡槽，4个SATA接口，说出来你可能不信，我要改装笔记本支持U.2服务器硬盘!没错，手上拿的是800GB的intel P3600硬盘，说性能吗，mlc万年传家宝有多耐草自然不用说，哪怕是洋垃圾写了几百TB也不怕，性能上intel同容量mlc固态读写速度自然比不上3550/1800MB每秒的三星960pro，但是价格摆在那，服务器盘量大便宜，以后还有垃圾捡，等以后淘汰了上个Oracle的6.4TB固态，有多爽就不用说了，既然m2接口可以转换u2接口，在现在普及m2的时代，上服务器硬盘也不是不可能，好了，动工。 当时实现M2的图 神机配置 开始，大家可能见过笔记本用台式机CPU，或者台式机级别的mxm独立显卡，但是，在nvme固态硬盘流行的今天，我想可以做点什么，手里有个p570wm笔记本，硬盘仓很大，可以放下15mm机械盘，我想既然能放15mm，那么，是否可以考虑一下把排线改造，增加nvme通道，和SATA接口整合到一起变成SFF－8639接口，然后上服务器U.2硬盘呢？说干就干，一看这个笔记本的结构，觉得可行，于是就动工了 给大家普及一下什么是U.2接口，所谓U.2就是SATA接口的基础上，增加了SAS服务器硬盘的电路，以及Nvme固态硬盘的线路，一个U.2接口可以支持任何协议的硬盘 说一下这台机器的来历，其实这台笔记本，你们当年应该有所耳闻，上过新闻的，还记得当年2014年京东21万的笔记本吗？没错！21万元!就是那台未来人类P57笔记本，实际上就是蓝天准系统P570WM模具贴个牌高价卖而已，当年2014年的配置达到了6核I7 4960X+两张gtx680sli的顶级配置，这笔记本说真的很BT，硬盘可以塞三个，还有一个光驱!现在2020年了，才开始普及6核心的笔记本，以前都是四核封顶，牙膏厂万年坑，唯独P570WM这台传奇机皇可以傲视群雄，放到现在，依然可以和蓝天P870TM笔记本相提并论，现在有很多淘汰的E5 2600处理器，很便宜性能也很强，P570WM上个E5 2697V2的12核心CPU，性能依然可以秒杀默认的9900k，而且CPU是四通道内存，就算是四根1600，性能也比双通道ddr4－3200强，服务器级别的配置，做到笔记本上，也是蓝天机皇的绝唱了，这台本子全球限量300台，十分稀有，然而，最大的短板就是，没有nvme固态硬盘，但是有多的显卡槽，在显卡性能强大的今天，我已经用不到双卡了，那么是否可以副卡位转接nvme呢？于是，开始了我的研究 成品上图 p.s.本人不想折腾图床，暂时用贴吧如有水印请勿奇怪。。。 配置升级。。。 卖了 ","link":"https://qqfloatingice.github.io/post/k/"},{"title":"俄罗斯方块","content":"声明 由于本人C++使用能力一直下滑（毕竟知道它没用-不考竞赛之后就没认真用过了）所以有BUG不要找我，我现在已经没有能力修他们了。。。。 本人的C++版本较早可能新版无法运行 /*******************************/ /******Writer: GJ *******/ /******Language: C *******/ /******Date: 2013 3 23 *******/ /*******************************/ #include&lt;iostream&gt; #include&lt;stdio.h&gt; //#include&lt;conio.h&gt; #include&lt;string.h&gt; #include&lt;time.h&gt; #include&lt;stdlib.h&gt; #include&lt;windows.h&gt; using namespace std; #define me(a) memset(a,0,sizeof(a)) #define judge(bl,ok) for(i=0;i&lt;5;i++)if(bl[i].x&amp;&amp;map[bl[i].x][bl[i].y])ok=0 #define is_pure(node,ok) if(map[node.x][node.y])ok=0 const int HEIGHT=24,LENGTH=40,SIDE=22; char INIT_MAP[HEIGHT+1][LENGTH+1]; int map[HEIGHT][SIDE]; struct node{int x,y;int color;}; const int TIME_DWELL=1000; int state=0; /**********获取句柄**********/ HANDLE Output=GetStdHandle(STD_OUTPUT_HANDLE); HANDLE Input=GetStdHandle(STD_INPUT_HANDLE); /**********设置光标位置**********/ void SetCursor(int x,int y){ COORD cd={x,y}; SetConsoleCursorPosition(Output,cd); } /**************初始化图**************/ void INITMAP() { for(int i=0;i&lt;HEIGHT;i++) for(int j=0;j&lt;SIDE;j++){ if(i==0||i==HEIGHT-1||j==0||j==SIDE-1)map[i][j]=1; else map[i][j]=0; } } /********右上方提前显示方块******/ node bl[5]; void Former_Print_block(int n) { int i; for(i=0;i&lt;5;i++){bl[i].x=bl[i].y=0;} if(n==0){ bl[0].x=3,bl[0].y=28; bl[1].x=3,bl[1].y=30; bl[2].x=4,bl[2].y=30; bl[3].x=4,bl[3].y=32; } if(n==1){ bl[0].x=3,bl[0].y=32; bl[1].x=3,bl[1].y=30; bl[2].x=4,bl[2].y=30; bl[3].x=4,bl[3].y=28; } if(n==2){ bl[0].x=3,bl[0].y=30; bl[1].x=4,bl[1].y=28; bl[2].x=4,bl[2].y=30; bl[3].x=4,bl[3].y=32; } if(n==3){ bl[0].x=3,bl[0].y=27; bl[1].x=3,bl[1].y=29; bl[2].x=3,bl[2].y=31; bl[3].x=3,bl[3].y=33; } if(n==4){ bl[0].x=3,bl[0].y=29; bl[1].x=3,bl[1].y=31; bl[2].x=4,bl[2].y=29; bl[3].x=4,bl[3].y=31; } if(n==5){ bl[0].x=3,bl[0].y=28; bl[1].x=4,bl[1].y=28; bl[2].x=4,bl[2].y=30; bl[3].x=4,bl[3].y=32; } if(n==6){ bl[0].x=3,bl[0].y=32; bl[1].x=4,bl[1].y=28; bl[2].x=4,bl[2].y=30; bl[3].x=4,bl[3].y=32; } for(i=0;i&lt;5;i++){ SetCursor(bl[i].y,bl[i].x); printf(&quot;■&quot;); } } /*********获取不同的方块,出现在中间***********/ node block[5];//全局使用的核心!!! void print_block(int n) {int i; for(i=0;i&lt;5;i++){block[i].x=block[i].y=0;} if(n==0){ block[0].x=1,block[0].y=7; block[1].x=1,block[1].y=9; block[2].x=2,block[2].y=9; block[3].x=2,block[3].y=11; } if(n==1){ block[0].x=1,block[0].y=11; block[1].x=1,block[1].y=9; block[2].x=2,block[2].y=9; block[3].x=2,block[3].y=7; } if(n==2){ block[0].x=1,block[0].y=9; block[1].x=2,block[1].y=7; block[2].x=2,block[2].y=9; block[3].x=2,block[3].y=11; } if(n==3){ block[0].x=1,block[0].y=7; block[1].x=1,block[1].y=9; block[2].x=1,block[2].y=11; block[3].x=1,block[3].y=13; } if(n==4){ block[0].x=1,block[0].y=9; block[1].x=1,block[1].y=11; block[2].x=2,block[2].y=9; block[3].x=2,block[3].y=11; } if(n==5){ block[0].x=1,block[0].y=7; block[1].x=2,block[1].y=7; block[2].x=2,block[2].y=9; block[3].x=2,block[3].y=11; } if(n==6){ block[0].x=1,block[0].y=11; block[1].x=2,block[1].y=7; block[2].x=2,block[2].y=9; block[3].x=2,block[3].y=11; } for(i=0;i&lt;5;i++){ SetCursor(block[i].y,block[i].x); printf(&quot;■&quot;); } } /*************按 上 键 旋转*************/ void Exchange(int m) { int i,ok=1; node blo[5]; for(i=0;i&lt;5;i++)blo[i]=block[i]; if(m==0){ if(state==0){ blo[0].x+=1;blo[0].y+=2;blo[2].x-=1;blo[2].y+=2;blo[3].x-=2; judge(blo,ok); if(map[blo[0].x][blo[0].y-2])ok=0; if(ok){for(i=0;i&lt;5;i++)block[i]=blo[i];state=1;} } else{ blo[0].x-=1;blo[0].y-=2;blo[2].x+=1;blo[2].y-=2;blo[3].x+=2; judge(blo,ok); if(map[blo[1].x-1][blo[1].y])ok=0; if(ok){for(i=0;i&lt;5;i++)block[i]=blo[i];state=0;} } } else if(m==1){ if(state==0){ blo[0].x-=1;blo[0].y-=2;blo[2].x-=1;blo[2].y+=2;blo[3].y+=4; judge(blo,ok); if(map[blo[1].x][blo[1].y-2])ok=0; if(ok)for(i=0;i&lt;5;i++){block[i]=blo[i];state=1;} } else { blo[0].x+=1;blo[0].y+=2;blo[2].x+=1;blo[2].y-=2;blo[3].y-=4; judge(blo,ok); if(map[blo[0].x-1][blo[0].y])ok=0; if(ok)for(i=0;i&lt;5;i++){block[i]=blo[i];state=0;} } } else if(m==2) { if(state==0) { blo[0].x+=1;blo[0].y-=2; blo[1].x+=1;blo[1].y+=2;blo[3].x-=1;blo[3].y-=2; judge(blo,ok); if(map[blo[0].x+1][blo[0].y]||map[blo[0].x-1][block[0].y]||map[blo[3].x][blo[3].y+2])ok=0; if(ok)for(i=0;i&lt;5;i++){block[i]=blo[i];state=1;} } else if(state==1) { blo[0].x+=1;blo[0].y+=2; blo[1].x-=1;blo[1].y+=2;blo[3].x+=1;blo[3].y-=2; judge(blo,ok); if(map[blo[0].x][blo[0].y+2]||map[blo[0].x][blo[0].y-2]||map[blo[3].x-1][blo[3].y])ok=0; if(ok)for(i=0;i&lt;5;i++){block[i]=blo[i];state=2;} } else if(state==2) { blo[0].x-=1;blo[0].y+=2; blo[1].x-=1;blo[1].y-=2;blo[3].x+=1;blo[3].y+=2; judge(blo,ok); if(map[blo[0].x+1][blo[0].y]||map[blo[0].x-1][blo[0].y]||map[blo[3].x][blo[3].y-2])ok=0; if(ok)for(i=0;i&lt;5;i++){block[i]=blo[i];state=3;} } else{ blo[0].x-=1;blo[0].y-=2; blo[1].x+=1;blo[1].y-=2;blo[3].x-=1;blo[3].y+=2; judge(blo,ok); if(map[blo[0].x][blo[0].y+2]||map[blo[0].x][blo[0].y-2]||map[blo[3].x+1][blo[1].y])ok=0; if(ok)for(i=0;i&lt;5;i++){block[i]=blo[i];state=0;} } } else if(m==3) { if(state==0){ blo[0].x+=1;blo[0].y+=2;blo[2].x-=1;blo[2].y-=2;blo[3].x-=2;blo[3].y-=4; judge(blo,ok); if(map[blo[0].x][blo[0].y-2]||map[blo[2].x][blo[2].y+2])ok=0; if(ok)for(i=0;i&lt;5;i++){block[i]=blo[i];state=1;} } else { blo[0].x-=1;blo[0].y-=2;blo[2].x+=1;blo[2].y+=2;blo[3].x+=2;blo[3].y+=4; judge(blo,ok); if(map[blo[0].x+1][blo[0].y]||map[blo[2].x-1][blo[2].y])ok=0; if(ok)for(i=0;i&lt;5;i++){block[i]=blo[i];state=0;} } } else if(m==5) { if(state==0) { blo[0].x+=2;blo[1].x+=1;blo[1].y+=2;blo[3].x-=1;blo[3].y-=2; judge(blo,ok); if(map[blo[3].x][blo[3].y+2])ok=0; if(ok)for(i=0;i&lt;5;i++){block[i]=blo[i];state=1;} } else if(state==1) { blo[0].y+=4;blo[1].x-=1;blo[1].y+=2;blo[3].x+=1;blo[3].y-=2; judge(blo,ok); if(map[blo[3].x-1][blo[3].y])ok=0; if(ok)for(i=0;i&lt;5;i++){block[i]=blo[i];state=2;} } else if(state==2) { blo[0].x-=2;blo[1].x-=1;blo[1].y-=2;blo[3].x+=1;blo[3].y+=2; judge(blo,ok); if(map[blo[3].x][blo[3].y-2])ok=0; if(ok)for(i=0;i&lt;5;i++){block[i]=blo[i];state=3;} } else{ blo[0].y-=4;blo[1].x+=1;blo[1].y-=2;blo[3].x-=1;blo[3].y+=2; judge(blo,ok); if(map[blo[3].x+1][blo[3].y])ok=0; if(ok)for(i=0;i&lt;5;i++){block[i]=blo[i];state=0;} } } else if(m==6) { if(state==0) { blo[0].y-=4;blo[1].x+=1;blo[1].y+=2;blo[3].x-=1;blo[3].y-=2; judge(blo,ok); if(map[blo[1].x][blo[1].y-2])ok=0; if(ok){for(i=0;i&lt;5;i++)block[i]=blo[i];state=1;} } else if(state==1) { blo[0].x+=2;blo[1].x-=1;blo[1].y+=2;blo[3].x+=1;blo[3].y-=2; judge(blo,ok); if(map[blo[1].x+1][blo[1].y])ok=0; if(ok){for(i=0;i&lt;5;i++)block[i]=blo[i];state=2;} } else if(state==2) { blo[0].y+=4;blo[1].x-=1;blo[1].y-=2;blo[3].x+=1;blo[3].y+=2; judge(blo,ok); if(map[blo[1].x][blo[1].y+2])ok=0; if(ok){for(i=0;i&lt;5;i++)block[i]=blo[i];state=3;} } else{ blo[0].x-=2;blo[1].x+=1;blo[1].y-=2;blo[3].x-=1;blo[3].y+=2; judge(blo,ok); if(map[blo[1].x-1][blo[1].y])ok=0; if(ok){for(i=0;i&lt;5;i++)block[i]=blo[i];state=0;} } } } /*********清除当前方块**********/ void clear_cube(node* block) { for(int i=0;i&lt;5;i++){ if(block[i].x){ SetCursor(block[i].y,block[i].x); printf(&quot; &quot;);} } } /*******打印当前方块*********/ void printt_cube(node* block) { for(int i=0;i&lt;5;i++){ if(block[i].x){ SetCursor(block[i].y,block[i].x); printf(&quot;■&quot;); } } } /**********按键***********/ void Move(int m,int n){ int i; if(n==0){//左 for(i=0;i&lt;5&amp;&amp;block[i].x;i++)if(block[i].y)block[i].y-=2; } if(n==1){//右 for(i=0;i&lt;5&amp;&amp;block[i].x;i++)if(block[i].y)block[i].y+=2; } if(n==2)//上 { Exchange(m); } if(n==3)//下 { int ok=1; while(ok){ for(i=0;i&lt;5;i++)if(block[i].x) if(map[block[i].x+1][block[i].y])ok=0; if(ok)for(i=0;i&lt;5;i++)if(block[i].x) block[i].x+=1; } } } /******判断是否可以向左移动*****/ int If_Can_Left(node* block) { int ok=1,i; int min=22; for(i=0;i&lt;5&amp;&amp;block[i].x;i++)if(block[i].y&lt;min)min=block[i].y; if(min-2&lt;1)ok=0; for(i=0;i&lt;5&amp;&amp;block[i].x;i++)if(block[i].x) if(map[block[i].x][block[i].y-2])ok=0; return ok; } /******判断是否可以向右移动********/ int If_Can_Right(node* block) { int ok=1,i; int max=0; for(i=0;i&lt;5&amp;&amp;block[i].x;i++)if(block[i].y&gt;max)max=block[i].y; if(max+2&gt;19)ok=0; for(i=0;i&lt;5&amp;&amp;block[i].x;i++)if(block[i].x) if(map[block[i].x][block[i].y+2])ok=0; return ok; } /*********打印图**********/ void print_map() { int i,j; me(INIT_MAP); for(i=0;i&lt;HEIGHT;i++) { if(i==0||i==23){ for(j=0;j&lt;LENGTH;j++)printf(&quot;%c&quot;,INIT_MAP[i][j]='-'); } else{ printf(&quot;%c&quot;,INIT_MAP[i][0]='|'); for(j=1;j&lt;SIDE-1;j++)printf(&quot;%c&quot;,INIT_MAP[i][j]=' '); printf(&quot;%c%c&quot;,INIT_MAP[i][j++]='|',INIT_MAP[i][j++]='|'); for(;j&lt;LENGTH-1;j++)printf(&quot;%c&quot;,INIT_MAP[i][j]=' '); printf(&quot;%c&quot;,INIT_MAP[i][j]='|'); } cout&lt;&lt;endl; } SetCursor(SIDE+1,10); printf(&quot;================&quot;); SetCursor(SIDE+1,11); printf(&quot;Speed&quot;); SetCursor(SIDE+1,13); printf(&quot;================&quot;); SetCursor(SIDE+1,14); printf(&quot;Score&quot;); SetCursor(SIDE+1,16); printf(&quot;================&quot;); SetCursor(SIDE+1,19); printf(&quot; Created By &quot;); SetCursor(SIDE+1,20); printf(&quot; Gong Jing &quot;); } /*******下降一格*******/ void cube_drop(node *block) { int i; for(i=0;i&lt;5;i++)if(block[i].x) block[i].x+=1; } /*****到达底部返回1*******/ int is_at_botton(node* block) { for(int i=0;i&lt;5;i++) if(block[i].x&amp;&amp;map[block[i].x+1][block[i].y])return 1; return 0; } /******到达底部map赋值为1*****/ void print_map(node *block) { int i; for(i=0;i&lt;5;i++){ if(block[i].x){ map[block[i].x][block[i].y]=1; SetCursor(block[i].y,block[i].x); printf(&quot;■&quot;); } } } /******是否可以消去并消去**********/ int Can_It_Cut() { int i,j; int cut=0; for(i=HEIGHT-2;i&gt;1;i--){ int ok=1; for(j=1;j&lt;SIDE-1;j+=2) if(map[i][j]==0){ok=0;break;} if(ok){ for(j=i;j&gt;1;j--)for(int k=1;k&lt;SIDE-1;k+=2) map[j][k]=map[j-1][k]; cut++;i++; } } for(i=HEIGHT-2;i&gt;1;i--) for(int j=1;j&lt;SIDE-1;j+=2) { SetCursor(j,i); if(map[i][j])printf(&quot;■&quot;); else printf(&quot; &quot;); } return cut; } /********是否GameOver********/ int is_gameover(int num) { int i,j,ok=1; print_block(num); for(i=0;i&lt;5;i++)if(block[i].x&amp;&amp;map[block[i].x][block[i].y])ok=0; if(!ok){ char aa[20]={&quot;Game Over!!!&quot;}; for(i=9;i&lt;12;i++) { if(i==10){ int t=0; for(int j=4;j&lt;18;j++){ SetCursor(j,i); if(j&gt;=5&amp;&amp;j&lt;17)printf(&quot;%c&quot;,aa[t++]); else printf(&quot; &quot;); } } else for(j=4;j&lt;18;j++){ SetCursor(j,i); printf(&quot; &quot;); } } SetCursor(1,12);printf(&quot; Enter To Continue. &quot;); SetCursor(1,13);printf(&quot; Esc To Escape. &quot;); SetCursor(1,14);printf(&quot; &quot;); } return ok; } /*******游戏结束，再来一局，清理屏幕******/ void Clear_map() { for(int i=22;i&gt;0;i--) for(int j=1;j&lt;SIDE-1;j+=2) { map[i][j]=0; SetCursor(j,i); printf(&quot; &quot;); } } int main() { srand(time(NULL)); print_map(); INITMAP(); int gameover=1; int ok=1;//用于判断游戏是否结束 while(gameover){ int Score=0; int Speed=0; int numm=(rand()%7)*(rand()%7)%7; Sleep(TIME_DWELL); while(ok) { SetCursor(SIDE+4+Speed,12); printf(&quot; &quot;); SetCursor(SIDE+4,15); printf(&quot; &quot;); SetCursor(SIDE+4+Speed,12); printf(&quot;*&quot;); SetCursor(SIDE+4,15); printf(&quot;%d&quot;,Score); Sleep(200); int num=numm; //第num个方块，初始时为0这个状态 numm=(rand()%7)*(rand()%7)%7; //提前显示的方块 clear_cube(bl); Former_Print_block(numm); //打印提前显示的方块 print_block(num); //打印要落下的方块初始位置 state=0; int botton=1;//用于判断是否已经落到底部 while(botton) { clear_cube(block); /**********键位响应**********/ if(GetAsyncKeyState(VK_LEFT)&amp;&amp;If_Can_Left(block))Move(num,0); else if(GetAsyncKeyState(VK_RIGHT)&amp;&amp;If_Can_Right(block))Move(num,1); else if(GetAsyncKeyState(VK_UP))Move(num,2); else if(GetAsyncKeyState(VK_DOWN)){Move(num,3);botton=0;} if(!is_at_botton(block))cube_drop(block); else botton=0; printt_cube(block);//打印当前方块 if(!botton)print_map( block); Sleep(100*(4-Score/80)); } int cut=Can_It_Cut(); if(cut){ Score+=cut*10; Speed=Score/80; } ok=is_gameover(numm); } if(GetAsyncKeyState(VK_ESCAPE))gameover=0; else if(GetAsyncKeyState(VK_RETURN)){Clear_map();ok=1;} } return 0; } ","link":"https://qqfloatingice.github.io/post/c4/"},{"title":"几个贪吃蛇","content":"声明 由于本人C++使用能力一直下滑（毕竟知道它没用-不考竞赛之后就没认真用过了）所以有BUG不要找我，我现在已经没有能力修他们了。。。。 本人的C++版本较早可能新版无法运行 壹 #include&lt;windows.h&gt; #include&lt;time.h&gt; #include&lt;stdlib.h&gt; #include&lt;conio.h&gt; #define N 21 #include&lt;iostream&gt; using namespace std; void gotoxy(int x,int y)//位置函数 { COORD pos; pos.X=2*x; pos.Y=y; SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE),pos); } void color(int a)//颜色函数 { SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),a); } void init(int apple[2])//初始化函数（初始化围墙、显示信息、苹果） { int i,j;//初始化围墙 int wall[N+2][N+2]={{0}}; for(i=1;i&lt;=N;i++) { for(j=1;j&lt;=N;j++) wall[i][j]=1; } color(11); for(i=0;i&lt;N+2;i++) { for(j=0;j&lt;N+2;j++) { if(wall[i][j]) cout&lt;&lt;&quot;■&quot;; else cout&lt;&lt;&quot;□&quot; ; } cout&lt;&lt;endl; } gotoxy(N+3,1);//显示信息 color(20); cout&lt;&lt;&quot;按 W S A D 移动方向&quot;&lt;&lt;endl; gotoxy(N+3,2); color(20); cout&lt;&lt;&quot;按任意键暂停&quot;&lt;&lt;endl; gotoxy(N+3,3); color(20); cout&lt;&lt;&quot;得分：&quot;&lt;&lt;endl; apple[0]=rand()%N+1;//苹果 apple[1]=rand()%N+1; gotoxy(apple[0],apple[1]); color(12); cout&lt;&lt;&quot;●&quot;&lt;&lt;endl; } int main() { int i,j; int** snake=NULL; int apple[2]; int score=0; int tail[2]; int len=3; char ch='p'; srand((unsigned)time(NULL)); init(apple); snake=(int**)realloc(snake,sizeof(int*)*len); for(i=0;i&lt;len;i++) snake[i]=(int*)malloc(sizeof(int)*2); for(i=0;i&lt;len;i++) { snake[i][0]=N/2; snake[i][1]=N/2+i; gotoxy(snake[i][0],snake[i][1]); color(14); cout&lt;&lt;&quot;★&quot;&lt;&lt;endl; } while(1)//进入消息循环 { tail[0]=snake[len-1][0]; tail[1]=snake[len-1][1]; gotoxy(tail[0],tail[1]); color(11); cout&lt;&lt;&quot;■&quot;&lt;&lt;endl; for(i=len-1;i&gt;0;i--) { snake[i][0]=snake[i-1][0]; snake[i][1]=snake[i-1][1]; gotoxy(snake[i][0],snake[i][1]); color(14); cout&lt;&lt;&quot;★&quot;&lt;&lt;endl; } if(kbhit()) { gotoxy(0,N+2); ch=getche(); } switch(ch) { case 'w':snake[0][1]--;break; case 's':snake[0][1]++;break; case 'a':snake[0][0]--;break; case 'd':snake[0][0]++;break; default: break; } gotoxy(snake[0][0],snake[0][1]); color(14); cout&lt;&lt;&quot;★&quot;&lt;&lt;endl; Sleep(abs(200-0.5*score)); if(snake[0][0]==apple[0]&amp;&amp;snake[0][1]==apple[1])//吃掉苹果后蛇分数加1，蛇长加1 { score++; len++; snake=(int**)realloc(snake,sizeof(int*)*len); snake[len-1]=(int*)malloc(sizeof(int)*2); apple[0]=rand()%N+1; apple[1]=rand()%N+1; gotoxy(apple[0],apple[1]); color(12); cout&lt;&lt;&quot;●&quot;&lt;&lt;endl; gotoxy(N+5,3); color(20); cout&lt;&lt;score&lt;&lt;endl; } if(snake[0][1]==0||snake[0][1]==N||snake[0][0]==0||snake[0][0]==N)//撞到围墙后失败 { gotoxy(N/2,N/2); color(30); cout&lt;&lt;&quot;失败！！！&quot;&lt;&lt;endl; for(i=0;i&lt;len;i++) free(snake[i]); Sleep(INFINITE); exit(0); } } return 0; } 贰 /************************贪吃蛇***********************/ /**********************2012-11-20*********************/ #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;ctime&gt; #include &lt;conio.h&gt; #include &lt;cmath&gt; #include &lt;windows.h&gt; using namespace std; /*** 光标定位 ***/ HANDLE hout=GetStdHandle(STD_OUTPUT_HANDLE); COORD coord; void locate(int x,int y) { coord.X=y; coord.Y=x; SetConsoleCursorPosition(hout,coord); }; /*** 隐藏光标 ***/ void hide() { CONSOLE_CURSOR_INFO cursor_info={1,0}; SetConsoleCursorInfo(hout, &amp;cursor_info); } /*** 生成随机数 ***/ double random(double start, double end) { return start+(end-start)*rand()/(RAND_MAX + 1.0); } /*** 定义地图的长宽，蛇的坐标，长度，方向，食物的位置 ***/ int m,n; struct node { int x,y; }snake[1000]; int snake_length,dir; node food; int direct[4][2]={{-1,0},{1,0},{0,-1},{0,1}}; /*** 输出墙 ***/ void print_wall() { cout &lt;&lt; &quot; &quot;; for (int i=1;i&lt;=n;i++) cout &lt;&lt; &quot;-&quot;; cout &lt;&lt; endl; for (int j=0;j&lt;=m-1;j++) { cout &lt;&lt; &quot;|&quot;; for (int i=1;i&lt;=n;i++) cout &lt;&lt; &quot; &quot;; cout &lt;&lt; &quot;|&quot; &lt;&lt; endl; } cout &lt;&lt; &quot; &quot;; for (int i=1;i&lt;=n;i++) cout &lt;&lt; &quot;-&quot;; } /*** 首次输出蛇，其中snake[0]代表头 ***/ void print_snake() { locate(snake[0].x,snake[0].y); cout &lt;&lt; &quot;@&quot;; for (int i=1;i&lt;=snake_length-1;i++) { locate(snake[i].x,snake[i].y); cout &lt;&lt; &quot;*&quot;; } } /*** 判断是否撞墙或者自撞 ***/ bool is_correct() { if (snake[0].x==0 || snake[0].y==0 || snake[0].x==m+1 || snake[0].y==n+1) return false; for (int i=1;i&lt;=snake_length-1;i++) { if (snake[0].x==snake[i].x &amp;&amp; snake[0].y==snake[i].y) return false; } return true; } /*** 随机生成并输出食物位置 ***/ bool print_food() { srand((unsigned)time(0)); bool e; while (1) { e=true; int i=(int) random(0,m)+1,j=(int) random(0,n)+1; food.x=i;food.y=j; for (int k=0;k&lt;=snake_length-1;k++) { if (snake[k].x==food.x &amp;&amp; snake[k].y==food.y) { e=false;break; } } if (e) break; } locate(food.x,food.y); cout &lt;&lt; &quot;$&quot;; return true; } /*** 蛇的前进 ***/ bool go_ahead() { node temp; bool e=false; temp=snake[snake_length-1]; for (int i=snake_length-1;i&gt;=1;i--) snake[i]=snake[i-1]; snake[0].x+=direct[dir][0]; snake[0].y+=direct[dir][1]; locate(snake[1].x,snake[1].y); cout &lt;&lt; &quot;*&quot;; /*** 吃到了食物 ***/ if (snake[0].x==food.x &amp;&amp; snake[0].y==food.y) { snake_length++; e=true; snake[snake_length-1]=temp; } /*** 输出此时蛇状态 ***/ if (!e) { locate(temp.x,temp.y); cout &lt;&lt; &quot; &quot;; } else print_food(); locate(snake[0].x,snake[0].y); cout &lt;&lt; &quot;@&quot;; /*** 如果自撞 ***/ if (!is_correct()) { system(&quot;cls&quot;); cout &lt;&lt; &quot;You lose!&quot; &lt;&lt; endl &lt;&lt; &quot;Length: &quot; &lt;&lt; snake_length &lt;&lt; endl; return false; } return true; } /*** 主函数 ***/ int main() { cout &lt;&lt; &quot;--------------------贪吃蛇---------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;请先输入两个数,表示地图大小.要求长宽均不小于10.&quot; &lt;&lt; endl; cout &lt;&lt; &quot;请注意窗口大小,以免发生错位.建议将窗口调为最大.&quot; &lt;&lt; endl; cout &lt;&lt; &quot;再选择难度.请在1-10中输入1个数,1最简单,10则最难&quot; &lt;&lt; endl; cout &lt;&lt; &quot;然后进入游戏画面,以方向键控制方向.祝你游戏愉快!&quot; &lt;&lt; endl; cout &lt;&lt; &quot;-----------------------------------------------&quot; &lt;&lt; endl; cin &gt;&gt; m &gt;&gt; n; if (m&lt;10 || n&lt;10 || m&gt;25 || n&gt;40) { cout &lt;&lt; &quot;ERROR&quot; &lt;&lt; endl; system(&quot;pause&quot;); return 0; } int hard; cin &gt;&gt; hard; if (hard&lt;=0 || hard&gt;100) { cout &lt;&lt; &quot;ERROR&quot; &lt;&lt; endl; system(&quot;pause&quot;); return 0; } /*** 数据全部初始化，包括蛇长，位置，方向 ***/ snake_length=5; clock_t a,b; char ch; double hard_len; for (int i=0;i&lt;=4;i++) { snake[i].x=1; snake[i].y=5-i; } dir=3; /*** 输出初始地图，蛇与食物 ***/ system(&quot;cls&quot;); hide(); print_wall(); print_food(); print_snake(); locate(m+2,0); cout &lt;&lt; &quot;Now length: &quot;; /*** 开始游戏 ***/ while (1) { /*** 难度随长度增加而提高 ***/ hard_len=(double)snake_length/(double) (m*n); /*** 调节时间，单位是ms ***/ a=clock(); while (1) { b=clock(); if (b-a&gt;=(int)(400-30*hard)*(1-sqrt(hard_len))) break; } /*** 接受键盘输入的上下左右，并以此改变方向 ***/ if (kbhit()) { ch=getch(); if (ch==-32) { ch=getch(); switch(ch) { case 72: if (dir==2 || dir==3) dir=0; break; case 80: if (dir==2 || dir==3) dir=1; break; case 75: if (dir==0 || dir==1) dir=2; break; case 77: if (dir==0 || dir==1) dir=3; break; } } } /*** 前进 ***/ if (!go_ahead()) break; /*** 在最后输出此时长度 ***/ locate(m+2,12); cout &lt;&lt; snake_length; } system(&quot;pause&quot;); return 0; } 叁 #include &lt;windows.h&gt; #include &lt;stdlib.h&gt; #include &lt;conio.h&gt; #include &lt;time.h&gt; #include &lt;cstring&gt; #include &lt;cstdio&gt; #include &lt;iostream&gt; #define N 22 using namespace std; int gameover; int x1, y1; // 随机出米 int x,y; long start; //======================================= //类的实现与应用initialize //======================================= //下面定义贪吃蛇的坐标类 class snake_position { public: int x,y; //x表示行，y表示列 snake_position(){}; void initialize(int &amp;);//坐标初始化 }; snake_position position[(N-2)*(N-2)+1]; //定义贪吃蛇坐标类数组，有(N-2)*(N-2)个坐标 void snake_position::initialize(int &amp;j) { x = 1; y = j; } //下面定义贪吃蛇的棋盘图 class snake_map { private: char s[N][N];//定义贪吃蛇棋盘，包括墙壁。 int grade, length; int gamespeed; //前进时间间隔 char direction; // 初始情况下，向右运动 int head,tail; int score; bool gameauto; public: snake_map(int h=4,int t=1,int l=4,char d=77,int s=0):length(l),direction(d),head(h),tail(t),score(s){} void initialize(); //初始化函数 void show_game(); int updata_game(); void setpoint(); void getgrade(); void display(); }; //定义初始化函数，将贪吃蛇的棋盘图进行初始化 void snake_map::initialize() { int i,j; for(i=1;i&lt;=3;i++) s[1][i] = '*'; s[1][4] = '#'; for(i=1;i&lt;=N-2;i++) for(j=1;j&lt;=N-2;j++) s[i][j]=' '; // 初始化贪吃蛇棋盘中间空白部分 for(i=0;i&lt;=N-1;i++) s[0][i] = s[N-1][i] = '-'; //初始化贪吃蛇棋盘上下墙壁 for(i=1;i&lt;=N-2;i++) s[i][0] = s[i][N-1] = '|'; //初始化贪吃蛇棋盘左右墙壁 } //============================================ //输出贪吃蛇棋盘信息 void snake_map::show_game() { system(&quot;cls&quot;); // 清屏 int i,j; cout &lt;&lt; endl; for(i=0;i&lt;N;i++) { cout &lt;&lt; '\\t'; for(j=0;j&lt;N;j++) cout&lt;&lt;s[i][j]&lt;&lt;' '; // 输出贪吃蛇棋盘 if(i==2) cout &lt;&lt; &quot;\\t等级：&quot; &lt;&lt; grade; if(i==6) cout &lt;&lt; &quot;\\t速度：&quot; &lt;&lt; gamespeed; if(i==10) cout &lt;&lt; &quot;\\t得分：&quot; &lt;&lt; score &lt;&lt; &quot;分&quot; ; if(i==14) cout &lt;&lt; &quot;\\t暂停：按一下空格键&quot; ; if(i==18) cout &lt;&lt; &quot;\\t继续：按两下空格键&quot; ; cout&lt;&lt;endl; } } //输入选择等级 void snake_map::getgrade() { cin&gt;&gt;grade; while( grade&gt;7 || grade&lt;1 ) { cout &lt;&lt; &quot;请输入数字1-7选择等级，输入其他数字无效&quot; &lt;&lt; endl; cin &gt;&gt; grade; } switch(grade) { case 1: gamespeed = 1000;gameauto = 0;break; case 2: gamespeed = 800;gameauto = 0;break; case 3: gamespeed = 600;gameauto = 0;break; case 4: gamespeed = 400;gameauto = 0;break; case 5: gamespeed = 200;gameauto = 0;break; case 6: gamespeed = 100;gameauto = 0;break; case 7: grade = 1;gamespeed = 1000;gameauto = 1;break; } } //输出等级，得分情况以及称号 void snake_map::display() { cout &lt;&lt; &quot;\\n\\t\\t\\t\\t等级：&quot; &lt;&lt; grade; cout &lt;&lt; &quot;\\n\\n\\n\\t\\t\\t\\t速度：&quot; &lt;&lt; gamespeed; cout &lt;&lt; &quot;\\n\\n\\n\\t\\t\\t\\t得分：&quot; &lt;&lt; score &lt;&lt; &quot;分&quot; ; } //随机产生米 void snake_map::setpoint() { srand(time(0)); do { x1 = rand() % (N-2) + 1; y1 = rand() % (N-2) + 1; }while(s[x1][y1]!=' '); s[x1][y1]='*'; } char key; int snake_map::updata_game() { gameover = 1; key = direction; start = clock(); while((gameover=(clock()-start&lt;=gamespeed))&amp;&amp;!kbhit()); //如果有键按下或时间超过自动前进时间间隔则终止循环 if(gameover) { getch(); key = getch(); } if(key == ' ') { while(getch()!=' '){};//这里实现的是按空格键暂停，按空格键继续的功能，但不知为何原因，需要按两下空格才能继续。这是个bug。 } else direction = key; switch(direction) { case 72: x= position[head].x-1; y= position[head].y;break; // 向上 case 80: x= position[head].x+1; y= position[head].y;break; // 向下 case 75: x= position[head].x; y= position[head].y-1;break; // 向左 case 77: x= position[head].x; y= position[head].y+1; // 向右 } if(!(direction==72||direction==80||direction==75 ||direction==77)) // 按键非方向键 gameover = 0; else if(x==0 || x==N-1 ||y==0 || y==N-1) // 碰到墙壁 gameover = 0; else if(s[x][y]!=' '&amp;&amp;!(x==x1&amp;&amp;y==y1)) // 蛇头碰到蛇身 gameover = 0; else if(x==x1 &amp;&amp; y==y1) { // 吃米，长度加1 length ++; if(length&gt;=8 &amp;&amp; gameauto) { length -= 8; grade ++; if(gamespeed&gt;=200) gamespeed -= 200; // 改变贪吃蛇前进速度 else gamespeed = 100; } s[x][y]= '#'; //更新蛇头 s[position[head].x][position[head].y] = '*'; //吃米后将原先蛇头变为蛇身 head = (head+1) % ( (N-2)*(N-2) ); //取蛇头坐标 position[head].x = x; position[head].y = y; show_game(); gameover = 1; score += grade*20; //加分 setpoint(); //产生米 } else { // 不吃米 s[position[tail].x][position[tail].y]=' ';//将蛇尾置空 tail= (tail+1) % ( (N-2) * (N-2) );//更新蛇尾坐标 s[position[head].x][position[head].y]='*'; //将蛇头更为蛇身 head= (head+1) % ( (N-2) * (N-2) ); position[head].x = x; position[head].y = y; s[position[head].x][position[head].y]='#'; //更新蛇头 gameover = 1; } return gameover; } //==================================== //主函数部分 //==================================== int main() { char ctn = 'y'; int nodead; cout&lt;&lt;&quot;\\n\\n\\n\\n\\n\\t\\t\\t 欢迎进入贪吃蛇游戏!&quot;&lt;&lt;endl;//欢迎界面; cout&lt;&lt;&quot;\\n\\n\\n\\t\\t\\t 按任意键马上开始。。。&quot;&lt;&lt;endl;//准备开始;; getch(); while( ctn=='y' ) { system(&quot;cls&quot;); // 清屏 snake_map snake; snake.initialize(); cout &lt;&lt; &quot;\\n\\n请输入数字选择游戏等级：&quot; &lt;&lt; endl; cout &lt;&lt; &quot;\\n\\n\\n\\t\\t\\t1.等级一：速度 1000 \\n\\n\\t\\t\\t2.等级二：速度 800 \\n\\n\\t\\t\\t3.等级三：速度 600 &quot;; cout &lt;&lt; &quot;\\n\\n\\t\\t\\t4.等级四：速度 400 \\n\\n\\t\\t\\t5.等级五：速度 200 \\n\\n\\t\\t\\t6.等级六：速度 100 \\n\\n\\t\\t\\t7.自动升级模式&quot; &lt;&lt; endl; snake.getgrade();//获取等级 for(int i=1;i&lt;=4;i++) { position[i].initialize(i);//初始化坐标 } snake.setpoint(); // 产生第一个米 do { snake.show_game(); nodead = snake.updata_game(); }while(nodead); system(&quot;cls&quot;); //清屏 cout &lt;&lt; &quot;\\n\\n\\n\\t\\t\\t\\tGameover！\\n\\n&quot;&lt;&lt;endl; snake.display();//输出等级/得分情况 cout &lt;&lt; &quot;\\n\\n\\n\\t\\t 是否选择继续游戏？输入 y 继续，n 退出&quot; &lt;&lt; endl; cin &gt;&gt; ctn; } return 0; } 肆 //******友情提示:如想速度快点,请改小_sleep(500)函数中参数***** #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;conio.h&gt; #include &lt;string.h&gt; #include &lt;time.h&gt; const int H = 8; //地图的高 const int L = 16; //地图的长 char GameMap[H][L]; //游戏地图 int key; //按键保存 int sum = 1, over = 0; //蛇的长度, 游戏结束(自吃或碰墙) int dx[4] = {0, 0, -1, 1}; //左、右、上、下的方向 int dy[4] = {-1, 1, 0, 0}; struct Snake //蛇的每个节点的数据类型 { int x, y; //左边位置 int now; //保存当前节点的方向, 0,1,2,3分别为左右上下 }Snake[H*L]; const char Shead = '@'; //蛇头 const char Sbody = '#'; //蛇身 const char Sfood = '*'; //食物 const char Snode = '.'; //'.'在地图上标示为空 void Initial(); //地图的初始化 void Create_Food(); //在地图上随机产生食物 void Show(); //刷新显示地图 void Button(); //取出按键,并判断方向 void Move(); //蛇的移动 void Check_Border(); //检查蛇头是否越界 void Check_Head(int x, int y); //检查蛇头移动后的位置情况 int main() { Initial(); Show(); return 0; } void Initial() //地图的初始化 { int i, j; int hx, hy; system(&quot;title 贪吃蛇&quot;); //控制台的标题 memset(GameMap, '.', sizeof(GameMap)); //初始化地图全部为空'.' system(&quot;cls&quot;); srand(time(0)); //随机种子 hx = rand()%H; //产生蛇头 hy = rand()%L; GameMap[hx][hy] = Shead; Snake[0].x = hx; Snake[0].y = hy; Snake[0].now = -1; Create_Food(); //随机产生食物 for(i = 0; i &lt; H; i++) //地图显示 { for(j = 0; j &lt; L; j++) printf(&quot;%c&quot;, GameMap[i][j]); printf(&quot;\\n&quot;); } printf(&quot;贪吃蛇\\n&quot;); printf(&quot;按任意方向键开始游戏\\n&quot;); getch(); //先接受一个按键,使蛇开始往该方向走 Button(); //取出按键,并判断方向 } void Create_Food() //在地图上随机产生食物 { int fx, fy; while(1) { fx = rand()%H; fy = rand()%L; if(GameMap[fx][fy] == '.') //不能出现在蛇所占有的位置 { GameMap[fx][fy] = Sfood; break; } } } void Show() //刷新显示地图 { int i, j; while(1) { _sleep(500); //延迟半秒(1000为1s),即每半秒刷新一次地图 Button(); //先判断按键在移动 Move(); if(over) //自吃或碰墙即游戏结束 { printf(&quot;\\n**游戏结束**\\n&quot;); printf(&quot; &gt;_&lt;\\n&quot;); getchar(); break; } system(&quot;cls&quot;); //清空地图再显示刷新吼的地图 for(i = 0; i &lt; H; i++) { for(j = 0; j &lt; L; j++) printf(&quot;%c&quot;, GameMap[i][j]); printf(&quot;\\n&quot;); } printf(&quot;\\n小小C语言贪吃蛇\\n&quot;); printf(&quot;按任意方向键开始游戏\\n&quot;); } } void Button() //取出按键,并判断方向 { if(kbhit() != 0) //检查当前是否有键盘输入，若有则返回一个非0值，否则返回0 { while(kbhit() != 0) //可能存在多个按键,要全部取完,以最后一个为主 key = getch(); //将按键从控制台中取出并保存到key中 switch(key) { //左 case 75: Snake[0].now = 0; break; //右 case 77: Snake[0].now = 1; break; //上 case 72: Snake[0].now = 2; break; //下 case 80: Snake[0].now = 3; break; } } } void Move() //蛇的移动 { int i, x, y; int t = sum; //保存当前蛇的长度 //记录当前蛇头的位置,并设置为空,蛇头先移动 x = Snake[0].x; y = Snake[0].y; GameMap[x][y] = '.'; Snake[0].x = Snake[0].x + dx[ Snake[0].now ]; Snake[0].y = Snake[0].y + dy[ Snake[0].now ]; Check_Border(); //蛇头是否越界 Check_Head(x, y); //蛇头移动后的位置情况,参数为: 蛇头的开始位置 if(sum == t) //未吃到食物即蛇身移动哦 for(i = 1; i &lt; sum; i++) //要从蛇尾节点向前移动哦,前一个节点作为参照 { if(i == 1) //尾节点设置为空再移动 GameMap[ Snake[i].x ][ Snake[i].y ] = '.'; if(i == sum-1) //为蛇头后面的蛇身节点,特殊处理 { Snake[i].x = x; Snake[i].y = y; Snake[i].now = Snake[0].now; } else //其他蛇身即走到前一个蛇身位置 { Snake[i].x = Snake[i+1].x; Snake[i].y = Snake[i+1].y; Snake[i].now = Snake[i+1].now; } GameMap[ Snake[i].x ][ Snake[i].y ] = '#'; //移动后要置为'#'蛇身 } } void Check_Border() //检查蛇头是否越界 { if(Snake[0].x &lt; 0 || Snake[0].x &gt;= H || Snake[0].y &lt; 0 || Snake[0].y &gt;= L) over = 1; } void Check_Head(int x, int y) //检查蛇头移动后的位置情况 { if(GameMap[ Snake[0].x ][ Snake[0].y ] == '.') //为空 GameMap[ Snake[0].x ][ Snake[0].y ] = '@'; else if(GameMap[ Snake[0].x ][ Snake[0].y ] == '*') //为食物 { GameMap[ Snake[0].x ][ Snake[0].y ] = '@'; Snake[sum].x = x; //新增加的蛇身为蛇头后面的那个 Snake[sum].y = y; Snake[sum].now = Snake[0].now; GameMap[ Snake[sum].x ][ Snake[sum].y ] = '#'; sum++; Create_Food(); //食物吃完了马上再产生一个食物 } else over = 1; } ","link":"https://qqfloatingice.github.io/post/c3/"},{"title":"计算用杨辉三角","content":"声明 由于本人C++使用能力一直下滑（毕竟知道它没用-不考竞赛之后就没认真用过了）所以有BUG不要找我，我现在已经没有能力修他们了。。。。 本人的C++版本较早可能新版无法运行 #include &lt;iostream&gt; using namespace std; //返回杨辉三角第x行第y列的值，起始行为第0行 int SanJiaoYang(int x,int y); int main() { int RowCount,i,j,k; cout &lt;&lt; &quot;请输入杨辉三角的行数:&quot;; while(cin &gt;&gt; RowCount) { for(i = 0;i &lt; RowCount;++i) { for(j = 1;j &lt; RowCount - i;++j)//打印第i行第一个元素前面的空格 { cout &lt;&lt; &quot; &quot;; } for(k = 1;k &lt;= i + 1;++k)//打印第i行的所有元素 { cout &lt;&lt; SanJiaoYang(i,k) &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; } cout &lt;&lt; &quot;请输入杨辉三角的行数:&quot;; } return 0; } //返回杨辉三角第x行第y列的值，起始行为第0行 int SanJiaoYang(int x,int y) { int z; if((y == 1) || (y == x + 1)) { z = 1; } else//y!=1且y!=x { z = SanJiaoYang(x - 1,y - 1) + SanJiaoYang(x - 1,y); } return z; } ","link":"https://qqfloatingice.github.io/post/c2/"},{"title":"CPU测试用杨辉三角","content":"声明 由于本人C++使用能力一直下滑（毕竟知道它没用-不考竞赛之后就没认真用过了）所以有BUG不要找我，我现在已经没有能力修他们了。。。。 本人的C++版本较早可能新版无法运行 #include&lt;iostream&gt; #include&lt;iomanip&gt; using namespace std; int* YangHuiData(int n); //n是杨辉三角形的行数 void YangHuiShow(int *pData, int n);//在屏幕上打印杨辉三角形 int main() { int n; cout &lt;&lt; &quot;请输入杨辉三角形的行数&quot;; cin &gt;&gt; n; //计算杨辉三角并保存到二维数组 int *pData = YangHuiData(n); //在屏幕上打印等腰三角形的杨辉三角 YangHuiShow(pData, n); //n是杨辉三角形的行数 } int* YangHuiData(int n) { int *a = new int[n*n]; //完成杨辉三角形的计算，没有显示的位置填0 int i, j; for (i = 0; i&lt;n*n; i++) { a[i] = 0; } a[0] = 1; a[n] = 1; a[n + 1] = 1; for (i = 2; i&lt;n; i++) { a[i*n] = 1; a[i*n + i] = 1; for (j = 1; j&lt;i; j++) { a[i*n + j] = a[(i - 1)*n + j - 1] + a[(i - 1)*n + j]; } } return a; } void YangHuiShow(int *a, int n) { //根据数据a指向的二维数组在屏幕上打印 //杨辉三角形，每行前面填充合适的空格 //以显示成等腰三角形，左右对称 int i, j; for (i = 0; i&lt;n; i++) { for (j = 0; j&lt;n - i - 1; j++) cout &lt;&lt; setw(3) &lt;&lt; &quot; &quot;;//前导空格，为单个数据的一半宽度 for (j = 0; j &lt;= i; j++) cout &lt;&lt; setw(6) &lt;&lt; a[i*n + j]; cout &lt;&lt; endl; } } ","link":"https://qqfloatingice.github.io/post/c0/"},{"title":"C++打飞机小游戏","content":"声明 由于本人C++使用能力一直下滑（毕竟知道它没用-不考竞赛之后就没认真用过了）所以有BUG不要找我，我现在已经没有能力修他们了。。。。 本人的C++版本较早可能新版无法运行 #include&lt;iostream&gt; #include&lt;windows.h&gt; #include&lt;conio.h&gt; #include&lt;time.h&gt; #include&lt;string&gt; using namespace std; /*=============== all the structures ===============*/ typedef struct Frame { COORD position[2]; int flag; }Frame; /*=============== all the functions ===============*/ void SetPos(COORD a)// set cursor { HANDLE out = GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleCursorPosition(out, a); } void SetPos(int i, int j)// set cursor { COORD pos = { i, j }; SetPos(pos); } void HideCursor() { CONSOLE_CURSOR_INFO cursor_info = { 1, 0 }; SetConsoleCursorInfo(GetStdHandle(STD_OUTPUT_HANDLE), &amp;cursor_info); } //把第y行，[x1, x2) 之间的坐标填充为 ch void drawRow(int y, int x1, int x2, char ch) { SetPos(x1, y); for (int i = 0; i &lt;= (x2 - x1); i++) cout &lt;&lt; ch; } //在a, b 纵坐标相同的前提下，把坐标 [a, b] 之间填充为 ch void drawRow(COORD a, COORD b, char ch) { if (a.Y == b.Y) drawRow(a.Y, a.X, b.X, ch); else { SetPos(0, 25); cout &lt;&lt; &quot;error code 01：无法填充行，因为两个坐标的纵坐标(x)不相等&quot;; system(&quot;pause&quot;); } } //把第x列，[y1, y2] 之间的坐标填充为 ch void drawCol(int x, int y1, int y2, char ch) { int y = y1; while (y != y2 + 1) { SetPos(x, y); cout &lt;&lt; ch; y++; } } //在a, b 横坐标相同的前提下，把坐标 [a, b] 之间填充为 ch void drawCol(COORD a, COORD b, char ch) { if (a.X == b.X) drawCol(a.X, a.Y, b.Y, ch); else { SetPos(0, 25); cout &lt;&lt; &quot;error code 02：无法填充列，因为两个坐标的横坐标(y)不相等&quot;; system(&quot;pause&quot;); } } //左上角坐标、右下角坐标、用row填充行、用col填充列 void drawFrame(COORD a, COORD b, char row, char col) { drawRow(a.Y, a.X + 1, b.X - 1, row); drawRow(b.Y, a.X + 1, b.X - 1, row); drawCol(a.X, a.Y + 1, b.Y - 1, col); drawCol(b.X, a.Y + 1, b.Y - 1, col); } void drawFrame(int x1, int y1, int x2, int y2, char row, char col) { COORD a = { x1, y1 }; COORD b = { x2, y2 }; drawFrame(a, b, row, col); } void drawFrame(Frame frame, char row, char col) { COORD a = frame.position[0]; COORD b = frame.position[1]; drawFrame(a, b, row, col); } void drawPlaying() { drawFrame(0, 0, 48, 24, '=', '|');// draw map frame; drawFrame(49, 0, 79, 4, '-', '|');// draw output frame drawFrame(49, 4, 79, 9, '-', '|');// draw score frame drawFrame(49, 9, 79, 20, '-', '|');// draw operate frame drawFrame(49, 20, 79, 24, '-', '|');// draw other message frame SetPos(52, 6); cout &lt;&lt; &quot;得分：&quot;; SetPos(52, 7); cout &lt;&lt; &quot;称号：&quot;; SetPos(52, 10); cout &lt;&lt; &quot;操作方式：&quot;; SetPos(52, 12); cout &lt;&lt; &quot; a,s,d,w 控制战机移动。&quot;; SetPos(52, 14); cout &lt;&lt; &quot; p 暂停游戏。&quot;; SetPos(52, 16); cout &lt;&lt; &quot; e 退出游戏。&quot;; } //在[a, b)之间产生一个随机整数 int random(int a, int b) { int c = (rand() % (a - b)) + a; return c; } //在两个坐标包括的矩形框内随机产生一个坐标 COORD random(COORD a, COORD b) { int x = random(a.X, b.X); int y = random(a.Y, b.Y); COORD c = { x, y }; return c; } bool judgeCoordInFrame(Frame frame, COORD spot) { if (spot.X &gt;= frame.position[0].X) if (spot.X &lt;= frame.position[1].X) if (spot.Y &gt;= frame.position[0].Y) if (spot.Y &lt;= frame.position[0].Y) return true; return false; } void printCoord(COORD a) { cout &lt;&lt; &quot;( &quot; &lt;&lt; a.X &lt;&lt; &quot; , &quot; &lt;&lt; a.Y &lt;&lt; &quot; )&quot;; } void printFrameCoord(Frame a) { printCoord(a.position[0]); cout &lt;&lt; &quot; - &quot;; printCoord(a.position[1]); } int drawMenu() { SetPos(30, 1); cout &lt;&lt; &quot;P l a n e W a r&quot;; drawRow(3, 0, 79, '-'); drawRow(5, 0, 79, '-'); SetPos(28, 4); cout &lt;&lt; &quot;w 和 s 选择， k 确定&quot;; SetPos(15, 11); cout &lt;&lt; &quot;1. 简单的敌人&quot;; SetPos(15, 13); cout &lt;&lt; &quot;2. 冷酷的敌人&quot;; drawRow(20, 0, 79, '-'); drawRow(22, 0, 79, '-'); SetPos(47, 11); cout &lt;&lt; &quot;简单的敌人：&quot;; SetPos(51, 13); cout &lt;&lt; &quot;简单敌人有着较慢的移动速度。&quot;; SetPos(24, 21); cout &lt;&lt; &quot;制作：汤宇轩&quot;; int j = 11; SetPos(12, j); cout &lt;&lt; &quot;&gt;&gt;&quot;; //drawFrame(45, 9, 79, 17, '=', '|'); while (1) { if (_kbhit()) { char x = _getch(); switch (x) { case 'w': { if (j == 13) { SetPos(12, j); cout &lt;&lt; &quot; &quot;; j = 11; SetPos(12, j); cout &lt;&lt; &quot;&gt;&gt;&quot;; SetPos(51, 13); cout &lt;&lt; &quot; &quot;; SetPos(47, 11); cout &lt;&lt; &quot;简单的敌人：&quot;; SetPos(51, 13); cout &lt;&lt; &quot;简单敌人有着较慢的移动速度，比较容易对付&quot;; } break; } case 's': { if (j == 11) { SetPos(12, j); cout &lt;&lt; &quot; &quot;; j = 13; SetPos(12, j); cout &lt;&lt; &quot;&gt;&gt;&quot;; SetPos(51, 13); cout &lt;&lt; &quot; &quot;; SetPos(47, 11); cout &lt;&lt; &quot;冷酷的敌人：&quot;; SetPos(51, 13); cout &lt;&lt; &quot;冷酷的敌人移动速度较快，难对付哟。&quot;; } break; } case 'k': { if (j == 8) return 1; else return 2; } } } } } /* DWORD WINAPI MusicFun(LPVOID lpParamte) { //DWORD OBJ; sndPlaySound(TEXT(&quot;bgm.wav&quot;), SND_FILENAME|SND_ASYNC); return 0; } */ /*================== the Game Class ==================*/ class Game { public: COORD position[10]; COORD bullet[10]; Frame enemy[8]; int score; int rank; int rankf; string title; int flag_rank; Game(); //初始化所有 void initPlane(); void initBullet(); void initEnemy(); //初始化其中一个 //void initThisBullet( COORD ); //void initThisEnemy( Frame ); void planeMove(char); void bulletMove(); void enemyMove(); //填充所有 void drawPlane(); void drawPlaneToNull(); void drawBullet(); void drawBulletToNull(); void drawEnemy(); void drawEnemyToNull(); //填充其中一个 void drawThisBulletToNull(COORD); void drawThisEnemyToNull(Frame); void Pause(); void Playing(); void judgePlane(); void judgeEnemy(); void Shoot(); void GameOver(); void printScore(); }; Game::Game() { initPlane(); initBullet(); initEnemy(); score = 0; rank = 25; rankf = 0; flag_rank = 0; } void Game::initPlane() { COORD centren = { 39, 22 }; position[0].X = position[5].X = position[7].X = position[9].X = centren.X; position[1].X = centren.X - 2; position[2].X = position[6].X = centren.X - 1; position[3].X = position[8].X = centren.X + 1; position[4].X = centren.X + 2; for (int i = 0; i &lt;= 4; i++) position[i].Y = centren.Y; for (int i = 6; i &lt;= 8; i++) position[i].Y = centren.Y + 1; position[5].Y = centren.Y - 1; position[9].Y = centren.Y - 2; } void Game::drawPlane() { for (int i = 0; i&lt;9; i++) { SetPos(position[i]); if (i != 5) cout &lt;&lt; &quot;O&quot;; else if (i == 5) cout &lt;&lt; &quot;|&quot;; } } void Game::drawPlaneToNull() { for (int i = 0; i&lt;9; i++) { SetPos(position[i]); cout &lt;&lt; &quot; &quot;; } } void Game::initBullet() { for (int i = 0; i&lt;10; i++) bullet[i].Y = 30; } void Game::drawBullet() { for (int i = 0; i&lt;10; i++) { if (bullet[i].Y != 30) { SetPos(bullet[i]); cout &lt;&lt; &quot;^&quot;; } } } void Game::drawBulletToNull() { for (int i = 0; i&lt;10; i++) if (bullet[i].Y != 30) { COORD pos = { bullet[i].X, bullet[i].Y + 1 }; SetPos(pos); cout &lt;&lt; &quot; &quot;; } } void Game::initEnemy() { COORD a = { 1, 1 }; COORD b = { 45, 15 }; for (int i = 0; i&lt;8; i++) { enemy[i].position[0] = random(a, b); enemy[i].position[1].X = enemy[i].position[0].X + 3; enemy[i].position[1].Y = enemy[i].position[0].Y + 2; } } void Game::drawEnemy() { for (int i = 0; i&lt;8; i++) drawFrame(enemy[i].position[0], enemy[i].position[1], '-', '|'); } void Game::drawEnemyToNull() { for (int i = 0; i&lt;8; i++) { drawFrame(enemy[i].position[0], enemy[i].position[1], ' ', ' '); } } void Game::Pause() { SetPos(61, 2); cout &lt;&lt; &quot; &quot;; SetPos(61, 2); cout &lt;&lt; &quot;暂停中...&quot;; char c = _getch(); while (c != 'p') c = _getch(); SetPos(61, 2); cout &lt;&lt; &quot; &quot;; } void Game::planeMove(char x) { if (x == 'a') if (position[1].X != 1) for (int i = 0; i &lt;= 9; i++) position[i].X -= 2; if (x == 's') if (position[7].Y != 23) for (int i = 0; i &lt;= 9; i++) position[i].Y += 1; if (x == 'd') if (position[4].X != 47) for (int i = 0; i &lt;= 9; i++) position[i].X += 2; if (x == 'w') if (position[5].Y != 3) for (int i = 0; i &lt;= 9; i++) position[i].Y -= 1; } void Game::bulletMove() { for (int i = 0; i&lt;10; i++) { if (bullet[i].Y != 30) { bullet[i].Y -= 1; if (bullet[i].Y == 1) { COORD pos = { bullet[i].X, bullet[i].Y + 1 }; drawThisBulletToNull(pos); bullet[i].Y = 30; } } } } void Game::enemyMove() { for (int i = 0; i&lt;8; i++) { for (int j = 0; j&lt;2; j++) enemy[i].position[j].Y++; if (24 == enemy[i].position[1].Y) { COORD a = { 1, 1 }; COORD b = { 45, 3 }; enemy[i].position[0] = random(a, b); enemy[i].position[1].X = enemy[i].position[0].X + 3; enemy[i].position[1].Y = enemy[i].position[0].Y + 2; } } } void Game::judgePlane() { for (int i = 0; i &lt; 8; i++) for (int j = 0; j&lt;9; j++) if (judgeCoordInFrame(enemy[i], position[j])) { SetPos(62, 1); cout &lt;&lt; &quot;坠毁&quot;; drawFrame(enemy[i], '+', '+'); Sleep(1000); GameOver(); break; } } void Game::drawThisBulletToNull(COORD c) { SetPos(c); cout &lt;&lt; &quot; &quot;; } void Game::drawThisEnemyToNull(Frame f) { drawFrame(f, ' ', ' '); } void Game::judgeEnemy() { for (int i = 0; i &lt; 8; i++) for (int j = 0; j &lt; 10; j++) if (judgeCoordInFrame(enemy[i], bullet[j])) { score += 5; drawThisEnemyToNull(enemy[i]); COORD a = { 1, 1 }; COORD b = { 45, 3 }; enemy[i].position[0] = random(a, b); enemy[i].position[1].X = enemy[i].position[0].X + 3; enemy[i].position[1].Y = enemy[i].position[0].Y + 2; drawThisBulletToNull(bullet[j]); bullet[j].Y = 30; } } void Game::Shoot() { for (int i = 0; i&lt;10; i++) if (bullet[i].Y == 30) { bullet[i].X = position[5].X; bullet[i].Y = position[5].Y - 1; break; } } void Game::printScore() { if (score == 120 &amp;&amp; flag_rank == 0) { rank -= 3; flag_rank = 1; } else if (score == 360 &amp;&amp; flag_rank == 1) { rank -= 5; flag_rank = 2; } else if (score == 480 &amp;&amp; flag_rank == 2) { rank -= 5; flag_rank = 3; } int x = rank / 5; SetPos(60, 6); cout &lt;&lt; score; if (rank != rankf) { SetPos(60, 7); if (x == 5) title = &quot;初级飞行员&quot;; else if (x == 4) title = &quot;中级飞行员&quot;; else if (x == 3) title = &quot;高级飞行员&quot;; else if (x == 2) title = &quot;王牌飞行员&quot;; cout &lt;&lt; title; } rankf = rank; } void Game::Playing() { //HANDLE MFUN; //MFUN= CreateThread(NULL, 0, MusicFun, NULL, 0, NULL); drawEnemy(); drawPlane(); int flag_bullet = 0; int flag_enemy = 0; while (1) { Sleep(8); if (_kbhit()) { char x = _getch(); if ('a' == x || 's' == x || 'd' == x || 'w' == x) { drawPlaneToNull(); planeMove(x); drawPlane(); judgePlane(); } else if ('p' == x) Pause(); else if ('k' == x) Shoot(); else if ('e' == x) { //CloseHandle(MFUN); GameOver(); break; } } /* 处理子弹 */ if (0 == flag_bullet) { bulletMove(); drawBulletToNull(); drawBullet(); judgeEnemy(); } flag_bullet++; if (5 == flag_bullet) flag_bullet = 0; /* 处理敌人 */ if (0 == flag_enemy) { drawEnemyToNull(); enemyMove(); drawEnemy(); judgePlane(); } flag_enemy++; if (flag_enemy &gt;= rank) flag_enemy = 0; /* 输出得分 */ printScore(); } } void Game::GameOver() { system(&quot;cls&quot;); COORD p1 = { 28,9 }; COORD p2 = { 53,15 }; drawFrame(p1, p2, '=', '|'); SetPos(36, 12); string str = &quot;Game Over!&quot;; for (int i = 0; i&lt;str.size(); i++) { Sleep(80); cout &lt;&lt; str[i]; } Sleep(1000); system(&quot;cls&quot;); drawFrame(p1, p2, '=', '|'); SetPos(31, 11); cout &lt;&lt; &quot;击落敌机：&quot; &lt;&lt; score / 5 &lt;&lt; &quot; 架&quot;; SetPos(31, 12); cout &lt;&lt; &quot;得 分：&quot; &lt;&lt; score; SetPos(31, 13); cout &lt;&lt; &quot;获得称号：&quot; &lt;&lt; title; SetPos(30, 16); Sleep(1000); cout &lt;&lt; &quot;继续？ 是（y）| 否（n）制作：汤宇轩&quot;; as: char x = _getch(); if (x == 'n') exit(0); else if (x == 'y') { system(&quot;cls&quot;); Game game; int a = drawMenu(); if (a == 2) game.rank = 20; system(&quot;cls&quot;); drawPlaying(); game.Playing(); } else goto as; } /*================== the main function ==================*/ int main() { //游戏准备 srand((int)time(0)); //随机种子 HideCursor(); //隐藏光标 Game game; int a = drawMenu(); if (a == 2) game.rank = 20; system(&quot;cls&quot;); drawPlaying(); game.Playing(); } 效果 ","link":"https://qqfloatingice.github.io/post/c1/"},{"title":"百度激励计划取消?狗屁！","content":"百度还是比我想的恶心 原作者：此店不售此书（Zander Alastor） 百度激励计划取消，皆大欢喜 百度发现终于瞒不住了，藏这么隐蔽，终究还是逃不过群众雪亮的眼睛 但是你官方的更新说明写的啥？ 敢不敢写明了？ 是不是又想过段时间风头过去就删证据？ 是不是又以为人们会逐渐遗忘？ 我们不会忘记！ 你做的好，我们会铭记，你做的差，也不要想掩盖！ We do not forgive 我们不会原谅 We do not forget 我们不会忘记 批判归批判，这次快速的修正，也说明了百度终于开始重视用户的意见，把用户的需求看进眼里了 百度再次明白用户不会傻傻的被割韭菜，而是知道如何争取应有的权利 望百度能够更加重视用户的呼声，真正做出有意义的举措 然而以上全为狗屁！实事并非如此！ 取消个鬼！我太天真了！ 4月20日21点，百度发公告承诺明天更新默认不勾选激励计划（仅仅只是不勾选激励计划，不是说取消P2P的上传），同时还说明了P2P是给在线观看和移动端下载加速。 感谢来自知乎用户黄瓜的信息 “ 如果取消勾选就能彻底关闭P2P服务，那百度可就太良心了。然而事实上P2P并不能关闭，百度对这点说的很明确，不能关闭（同时百度还说过，下载不限速）。所以，你不打勾，仅仅是没积分而已，该上传还是会上传。” “ 打算继续用百度网盘的话，建议开着激励计划，毕竟这是你唯一能从百度身上薅走一根毛的机会。 百度的上传不是现在才有的，已经存在很久了，现在只是多出了个激励计划。我以前就说过百度网盘会P2P会强制上传，限制上传速度的功能没用，当时信的不多。 百度就是个带有云盘功能的大号P2P，和当年的迅雷很像。只是比迅雷运营的成功多了，赚了一波好名声，至今有不少人觉得百度网盘是网盘界的救世主，是最良心最便宜最具性价比的网盘，很可惜，百度网盘从来都不符合这些标签。 百度网盘最大的优势就是资源多，再没别的了。价格，空间，服务，都不是最好的。良心二字更是万万扯不上关系滴。比如腾讯微云就比它强，空间更大，功能更多，价格更便宜，还没有P2P。(这里只是举个友商衬托的例子，不是说微云就多么好，我不做导购推荐，诸位慎重购买) 不过百度这P2P还挺有意思的，以前你不开会员还没资格加入P2P，必须付费，才有资格享受满带宽上传。现在有激励计划了，不知道免费用户有没有享受到这份殊荣。” 他们这群人，又想吃人，又是鬼鬼祟祟，想法子遮掩，不敢直截下手，真要令我笑死。我忍不住，便放声大笑起来，十分快活。自己晓得这笑声里面，有的是义勇和正气。 ——鲁迅 ","link":"https://qqfloatingice.github.io/post/b8/"},{"title":"百度网盘用户激励计划？割韭菜计划！","content":"原作者：此店不售此书（Zander Alastor） 先放证据： 为防止百度偷偷去除这项”操作“，先把图给配上 乍一看，挺香？“闲置“带宽和空间换积分？ 先看看积分计算 “ 1M上传速度，客户端不关，7小时，一个月能获得1000积分 1M，每天7小时要上传125kb×3600×7=25.2G **一个月要上传25.2×30=756GB，而且保持210小时电脑不关，才能拿到1000积分 一开始以为是1M带宽，125kb上传速度，评论区老铁提醒，人家要的是你的全部上传速度 我50m联通宽带，顶格上传速度是2.2M，一般人家也就20M宽带，就是你每天开7小时 一个月连张800积分，5分钟体验卷都捞不到，还要搭进去电费损耗 电费，损耗，你给我出吗？” 来自知乎作者：伍子胥是我偶像 来看看能换啥”好东西“！ IphoneX！我的天！这么大方的吗？！！！ ” 我来告诉大家最短多长时间能兑换iPhone X（700000积分） 首先是上传，一个月1000积分；手机端签到（不可断签），一周80积分；手机端每日任务（一个不落），一周210积分；综合下来一年能获得1000×12+(210+80)×(365/7)=27121积分。 只需要坚持弄 25.8年 就可以兑换咯，太良心了！ 当然，百度还时不时会开签到看广告积分翻倍的活动 如果你愿意每天额外花30秒来看广告的话，那么一年就可以获得1000×12+(210+80×2)×(365/7)=31292积分 现在只需要 22.3年 就能换到iPhone X了呢，是不是很划算？ 如果你还觉得很满意并且打算开始做的话，那我还得提醒你一句 百度网盘的积分是次年清零的！！ 结论：根本无法兑换iPhone X 百度从来没让我失望！“ 以上分析来自作者：Zhang Sacha 你以为只有这个很傻*吗，百度从不会让我失望！ 别忘了，拼死拼活一个月只能有1000积分！ 这800积分一个5分钟下载？！！下个啥？ 我每天花费时间，花费带宽，花费电钱，就给我个每月一次5分钟？ 5分钟下载券目前官方优惠价格1.9元，不优惠5元! 我电费都不止！ 而且正常用户真的能够这么持续签到？不间断？谁干啊！ 那其他的兑换呢？ 说真的，没啥用！宣传的爱奇艺vip都下架了！ 其他东西，您仔细品品，有几个有用的？连个抱枕都要8000积分！我一年电费换个地摊货？ 重点是很多人被默认开启了这个功能根本不知道！！！ 这个所谓的用户激励计划是默认开启的，在桌面端，必须进入几层设置界面才能发现，藏得老深了！ 百毒网盘→设置→传输→高级设置（真·隐蔽）→激励计划 很多人网费，电费莫名其妙被百度抢了都不知道！ 用户的知情权何在？！ 关于用户激励计划可以提升下载速度？ 我都没必要再吐槽了，毒盘什么速度？用户不清楚？ 你上传速度真快！占用我带宽就有1mb/s！可你下载不是照样20kb/s？ 普通用户就不是用户了？我花费设备，花费电费，花费时间，给你占用我带宽，那我的速度提升在哪里？ 普通用户就应该给SVIP提供更好的下载？自己没有像样回报？一切还是不知情状况下发生的？ SVIP：错错错，说的好像我就快了一样 是的，就算SVIP也没多少提升，该限速照样限速 你百度说自己服务器不行，太穷了，现在用用户的带宽，用户的电费，用户的硬件 你可把下载速度限制打开行吗？ 都用的我的了，还不让我好好用？ 我付出这么多，就给我百分之一的速度作为回报？ 大公司，大企业，独占市场，说话硬气，但是请把用户当人看，行吗？ 我要求不高，能正常速度下载就行！ 上传的时候你可没说可能下载不下来啊 我东西都给你了，只能任你摆布，我服 可你也别一点都不留活路啊 拿人手长，给人手短 你可做做人吧 “赞美”环节 “ 多好的一款软件啊！作为国内一个垄断的下载软件，在没有充钱的时候，下载速度竟然高达100kb每秒！下载一个5GB的东西，只要一天就可以了！仅仅是一天！！太感人的速度啊！更重要的是，平时在网络上找到资源，要下载的时候竟然超过了10MB就要下载百度网盘客户端才能下载，看看百度为了保护我们的数据安全多花心思！哪怕为了安全占用系统存储200MB、系统运存1GB也太值得了！还有里面那些商城，什么杂七杂八的东西，花里胡哨而又不失整体感，个个精美而且必须花钱，一个简简单单的下载软件，被装饰成了一个什么都不知道的东西。可见百度的思想有多么丰富！他们的产品策划做的多么优秀！综上所述，百度网盘真的是一个非常不错的下载软件！！缓慢的下载速度，让我们放慢生活的脚步；推荐（强制）下载客户端，让我们畅游在一个小小（非常非常小）的世界里；各种增强辅助的（乱七八糟不必要的）功能，让小小的世界也不失各种精彩（太精彩了）！也正是在这个网盘里，让我们真正体会到了弱肉强食（你充钱了就碾压那些免费用户），让我们努力赚钱，提升自己，让自己变成生活中的强者！艾玛，我太感动了！如此优秀的设计语言，必须让我给百度网盘一星评价！值了！！百度网盘还教会我们如何在慢节奏中体验生活，用最缓慢的蓝色进度条暗喻学习只有这样 心静如水 才能得到最完美的成绩！不充钱时平均下载速度100KB/s，用这种方式悄悄表达对孩子们拿到满分考卷的祝福！同时告诉满分值为120或150的孩子们要有进取之心，不可卡死在小学的满分线上！整个界面以蓝白为主色调，明明是活泼的颜色搭配却显得毫无生机甚至使人不由得充满怨气！是多么精妙的设计才能出现这样的效果啊！从我开始下载文件到现在，我的电脑风扇声音一直没停下来过，这难道不正是对开发者的赞美吗！一台风扇一间小屋和一台电脑！成就如此伟大的软件！这么棒的软件怎么能给五星呢！一星安排！” 来自b站用户的“赞美” ” 一些食客因家中炊具简陋不堪，恰巧村中富豪放出话来，为大家免费蒸饭。众人大喜，纷纷将米饭委托给大富豪。 富豪蒸熟了，却告诉食客，想吃他的米饭要用他专用的饭碗。但是这饭碗很小，小到每个碗只能装一两粒米，想用大碗要掏钱。众食客无奈掏了钱，发现所谓的大碗也只是略大了一点而已。众人大怒，怒骂其无良，存心戏弄我等。厨师轻蔑一笑说“你们可以不来我这吃啊，贱！”。众食客忿忿不平，却无话可说。 这时一人悄声出现，为众人发放自制饭碗，这饭碗上印着富豪家饭碗的印记，比众人的普通饭碗大了不少，却分文不取。众食客大喜，纷纷向其表示感谢。 如此日子过了许久，富豪也听说了这个人做的事情，顿时恼羞成怒，大骂那人无耻之尤，转头急奔官府，涕流满面哭诉自己被窃米万斤许，言那人居心不良，为探听食客隐秘之事，私贩假碗，获赃款达三十万两。罪罪桩桩，罄竹难书。 官府闻言，怒发冲冠，令官差将那人逮捕入狱等待发落。 富豪成了事，春风得意回到家里，砸了所有的假碗，笑之曰：“我能给你们这碗已经良心之极，你们居然还行此苟且之事！以后想吃饭要再加一个条件，每吃一碗就拿家里一件隐秘之事作为交换，我们会为你量身定制饭碗，还不说声谢谢富豪大爷？”。 众人怒目而视。有人心有戚戚，有人忿忿不平，有人暗道可惜，有人掩面而泣，却无一人应之。 一人看了看手中被砸的稀烂的碗，又看了看为自己量身定做的“好碗”，蓦然起身高呼：“那厮不是东西，偷窃大老爷的米饭，活该之极！大老爷给的碗合适的紧，感谢大老爷！” 一人呼，其旁者大呼，周遭众人亦大呼，俄而百千人大呼。 不平者无可闻也。 “ 来自知乎用户的”赞美“ 东西太多了，这里说不完，道不尽 ","link":"https://qqfloatingice.github.io/post/b7/"},{"title":"细数百度的过错","content":"原作者：此店不售此书（Zander Alastor） pandownload事件发生后，各类话题已经不断，但是还没有详细说明百度自身过错的文章。 这里发表下我个人对百度的看法，无关于pandownload事件。 一、百度不注重用户隐私 想必很多人虽然没有亲身经历，但是可能都知道这么一件实事：百度网盘中的内容会被替换成“8秒”或“无法查看”。 对于这我不必细说，我只想问百度，如何判断一个文件违规？ 很明显，这不是AI智能审核的功劳，毕竟早在多年前，甚至可以说是伴随百度云问世一来就有的”传统“。 那么就只能是人工审核了！ 有授权的员工就可以访问！ 您再细品，为什么这里提及了加强员工素质？ 试想一下，你存在云端的数据，可能被无数的百度员工查看，浏览，甚至会被强制修改！ 用户的隐私权何在？ 百度网盘是否真的在乎那些流量我是真搞不清楚，为什么要默认开启文件，照片，联系人的备份功能？ 周知，这种默认开启的功能，很多普通用户是不会进行更改的。（正如很多流氓软件的受害者，一直不会关闭诸如广告弹窗，新闻推送，开机提示等功能一样） 可以预测，很大一部分用户的数据就这样被上传到了百度网盘中，甚至有些用户还毫不知情！ 而且我更想吐槽的是，这种设置项，一般会进行云记录。可是每次这种文件备份的设置，重新安装百度网盘后，又是提示默认开启，这不明摆这想要我数据吗！这点我会在下面提到 二、百度网盘绝不会造成亏损 大家都看到，百度一直在宣传自己因为网盘服务的亏损，可是一个资本家，哪个会天真的保留亏损的项目？ 真以为百度会用爱发电？别太天真！ 看看真实的情况： 百度医生关闭 魏则西事件之后，百度医疗搜索备受质疑，百度也正在竭力摆脱医疗搜索带来的不良印象，正式下线了一款跟医疗搜索并不相关的业务—— 百度医生 。 百度贱卖移动游戏业务 百度19亿美元全资收购91无线，这也是中国互联网上最大金额并购案。在此之上百度整合成立百度移动游戏，仅四年的时间，百度却仅以12亿元的价格把百度移动游戏出售。 百度空间关闭 百度空间诞生于2006年，当年大量用户都在使用百度空间服务，但2012年（百度）擅自把用户的版面和评论都清除，以致于最终被用户抛弃。 百度未来商店关闭 2016年6月，百度发布公告表示其电商服务——百度未来商店已于2016年6月15 日关停。 百度说吧关闭 百度说吧于 2010 年 9 月 16 日上线，成立不到一年的百度说吧于 2011 年 8 月 22 日起停止所有说吧服务。 等等，还有很多，这里不便细数。 百度向来不会保留没有未来的项目，可是为什么至今还留有所谓大亏损的百度网盘呢？ 这里要提及一个大背景——人工智能 数据是每一个向人工智能进军的企业日思夜想的宝贵资源！ 很多企业想要获得数据，不得不通过购买等方式。 然而百度，却可以随意的使用我们的数据。 “李彦宏：中国人愿意用隐私换效率” 我就反问一句，隐私早就没了，效率如今在哪？ 我们储存在网盘中的海量数据，对于训练人工智能而言，是无价的财富。而我们，为百度的AI贡献出了这么多力量，换来的却是SVIP都带不动的速度！ 很多人会洗百度网盘，说SVIP有时候网盘速度高达1mb/s！这么良心！ 然而你上传个大文件试试，你对比看看上传速度是下载速度的几倍？ 那为啥上传这么快？想要你数据呗！伸手拿用户数据当然勤快了！给你下载就千方百计限制，只进不出！ 网盘服务给百度提供的数据量的价值，早就远超亏损了！否则为什么还不砍掉网盘？ 以上纯属个人观点，不喜请怒喷，为百毒的负评贡献一份力 😄 ","link":"https://qqfloatingice.github.io/post/b6/"},{"title":"软件黑名单","content":"由于看到部份群友饱受流氓软件困扰，笔者在此处列出部份黑名单。。。。 PC端 目前Windows桌面端所有的 国产 PC软件（99%）均为流氓软件，当然也有1%的大小厂出品的只做功能良心客户端。。。。扎心了 随便举几个例子： 特级 1.2345全家桶 2.360全家桶 3.腾讯全家桶 4.百度全家桶 5.金山全家桶 6.瑞星全家桶 7.搜狗全家桶 。。。。。。。 一般 一搜工具条 完美网译通 CNIC中文上网 博采网摘 百度搜霸 3721上网助手 Dudu下载加速器 很棒小秘书 网络猪 划词搜索7a64e58685e5aeb931333233663533 eBay工具条 娱乐心空 Yahoo助手(原3721) 搜狗 彩信通 16.360搜 17.多多QQ表情 18.易趣工具栏 19.很棒通行证 20.搜易网弹出广告 21.天下搜 22.U88财富快车工具条 23.唯刊 24.完美网译通 25.协和医院弹出广告 26.YOK工具条 27.桌面传媒(Desktop media) 28.酷站导航 29.中网媒体速递 30.DIY彩秀 31.电鹰搜索 32.SearchNet(中搜地址栏搜索) 33.New.net 34.Xbar 图铃随e下 35.win survey (MSIBM) 36.ZCOM 37.搜搜工具条(SOSO) 38.ShareHelper 39.播霸猫眼网络电视迷你版 40.天天搜索 41.SeAD/DmAD 42.酷客娱乐平台 43.Bysoo百搜工具栏 44.Infofo工具栏 45.ishare 46.酷猴 47.MSser 48.ZDA WebMisc天网广告软件 49.Win stdup 50.网址极限 51.Copyso 拷贝搜 52.搜狗直通车 53.8848购物搜索 54.IE伴郎 55.51888彩信助手 56.青娱乐 57.虎翼DIY吧 58.迷你PP 59.迷你迅雷 60.Alibaba商机直通车 61.网易搜霸 62.搜一搜 63.17lele网游 64.新浪iGAME游戏总动园 65.新浪点点通 66.miphone小蜜蜂 67.金山产品下载器 68.Ibar 69.DMCast桌面传媒 70.私人磁盘 71.极品数字网络电视 72.NetFish网络钓鱼克星 73.T2BHO 74.开心运程速递插件 75.Xplus 76.ADDeliverer 77.TargetAD 78.DTservice 79.EliteBar 80.ADO 81.EyeOnIE class 82.Router layer 83.InsII 84.Hotbar 85.Netbus Toolbar 86.31G上网直通车 87.139LOVE 88.Urlcom 89.Sol099 90.wz101 91.ADNavihepler(女生宿舍) 92.自由行中文域名 93.赢政天下网摘 94.易搜搜索引擎 95.迅彩图铃通 96.新浪VIVI收藏夹 97.新华快信 98.网游天使自助远程挂机平台 99.网易SMS Ppinstall Control 100.网眼天下WebEye 101.同花顺工具条 102.天天在线.黑龙江PortalCom Control2.0 103.腾讯极速下载控件 104.闪电搜霸Flashbar 105.塞我网CyworldChina 106.亲亲娱乐伴侣 107.每步直达网址 108.空中网彩信通 109.九寻音乐 音乐搜索伴侣软件1.0.0.3 110.金山安全助手 111.金盒子MultiUpload 112.广东互联星空CertInstall Control 113.恶意网站克星 木马间谍克星 114.初收获工具条 115.藏鲸阁 116.百易汉字域名 117.百度搜索伴侣 118.百度超级搜霸 119.爱美思中文邮址 120.阿里巴巴智能搜索 121.Yoday 122.xintv.com Timer Object 123.Kincent Q.Audio Control Class 124.K65.net组件 127.HarrySou ToolBar 128.EPSON Web Printer-SelfTest Control Class 129.ClockSync 130.668企业通道工具栏 131.Flash 其实还有更多这里给个大概类型（一下均为国产软件或国内代理软件） 1.2345XXX ​ 2.360XXX ​ 3.腾讯XXX ​ 4.百度XXX ​ 5.金山XXX ​ 6.瑞星XXX ​ 7.搜狗XXX 8.XXX安全卫士 9.XXX助手 10.XXX输入法 安卓端 由于大部分国产APP都会后台自启动，并读取用户各种隐私数据，所以国产app，国内代理APP,几乎均为流氓软件。。。。（国内定制的安卓其实自己就是流氓软件。。。） 这里因为我几乎不用安卓我就不一一列举了。。。 IOS端 几乎没有，IOS真香。。。。 MAC OS 几乎没有，虽然我不是果粉，但是苹果真香。。。 Linux 几乎没有 ｅｍｍｍ好像有deeping后有了。。。 但是我不知道。。。 以上纯属个人观点，不喜请怒喷，为流氓软件的消失尽一份力 😄 ","link":"https://qqfloatingice.github.io/post/b4/"},{"title":"kaios常见问题指南","content":"Nokia 8110 4G 拨号盘神秘代码 OneKeyOmniSD - 一键安装OmniSD 【清水博客汉化】Wallace Toolbox——折腾kaiOS手机的全能APP 把香蕉“掰直”：Nokia 8110 4G 刷入GerdaOS(此教程仅限8110) 把掰直的香蕉掰回去——8110恢复原厂系统教程 修改8110的开机第一屏 如何自定义8110的开机声音 如何更改8110的应用图标 8110的隐藏闹钟铃声 修复8110的按键速度 如何更换8110的开机动画 在8110上实现截屏(此教程仅限8110) 8110-800-2720使用电信卡 ","link":"https://qqfloatingice.github.io/post/a9/"},{"title":"【转】8110-800-2720使用电信卡","content":"​ 这三个手机都可以通过开通VoLTE来使用电信卡，但是只能在有4G信号的时候使用，没有4G信号时，数据流量，电话都不可用。 ​ 1.先开通VoLTE，营业厅、网上营业厅、发送 &quot;ktvolte&quot; 到 10000皆可 ​ 2.将电话卡插♂到主卡槽处(电池处，不要插♂错♂了)，副卡槽不能有卡。 ​ 3.重启后任务栏中会出现VoLTE图标 ，运营商显示&quot;中国电信&quot; ————转自QQ old ice 的KaiOSlab ","link":"https://qqfloatingice.github.io/post/a8/"},{"title":"emmmm","content":"今天学校又有好几个发烧的，不知道开学还能不能持续下去 。。。。 。。。。 。。。。 。。。。 我不想再上网课了 。。。。 。。。。 。。。。 。。。。 我想继续在学校里上课。。。。 ","link":"https://qqfloatingice.github.io/post/a5/"},{"title":"开学了","content":"emmmm，由于本人是苦逼初三党学业要紧，目前本博客会长期停更。。。。 ","link":"https://qqfloatingice.github.io/post/a4/"},{"title":"英特尔XTU解析--如何使用这把双刃剑？","content":"声明 本文由个人XTU使用心得见解，以及NBC发布的XTU降压教程结合而来。若有任何错误，请大家及时指出。毕竟XTU使用有风险，我不希望对其他玩家产生误导。 如第一句所言，XTU是一个有风险的软件，使用不当可能会带来严重后果，轻则蓝屏重启，重则CPU直接升天。因此本人建议： 1.确认一下自己的机器确实是Intel的CPU，而不是当年去实体店被人坑回来的小红标四连击的联想G50，或者是花大钱买的S7ZC。 2.在更改任何设置并且按下确定之前，请仔细检查自己的各项设置是否合理。永远不要把任何设置拉到顶，除非你确定以及肯定这不会出现任何问题。 3.请使你安装了XTU的机器远离你的仇人或者熊孩子，如果对方略懂硬件知识，最好不要让他进你的房间，以免因为机器的硬件损坏而导致后续的流血事件。 4.电压调整可以带来功耗的减少，也就是说，在给定的PL1（通俗点就是长时功耗墙）下可能有性能的提升。随着时间推移，电压调整所获得的收益将减少。这对外频与睿频频率没有影响。在机器进行调试之时，这项功能应该关闭，来确保随着时间推移，机器的功耗与性能表现符合预期。 ----来自英特尔7代标压处理器家族手册第一版（7th-gen-core-family-mobile-h-processor-lines-datasheet-vol-1），第四章第七条。 最后，本文仅提供“建议”而非“要求”或者“真理”，如果因为观看此贴，心血来潮，因为自己设置不当而弄坏了自己的机器，本人概不负责。 NBC的XTU降压教程网址：NBC的XTU降压教程网址：；英特尔7代标压处理器家族手册第一版网址： 英语不错的同学可以上去读一读 1.XTU下载 那么。。。在哪里找得到呢？ 百度XTU，下载英特尔®至尊调优实用程序（这中二的名字。。。是不是请了日本轻小说的作者来命名的）安装，收工。 至于支持列表没有自己的CPU型号？无需在意，这里只是列出了英特尔K/X系列的CPU，毕竟XTU是官方超频软件，列出的型号是针对超频而言的，其他的CPU型号一样可以进行降压/解锁功耗的操作。不过能不能调节电压功耗还是要看自己机器的BIOS和EC是否锁住了部分关键设置。 2.XTU各功能介绍 XTU之所以是XTU，正是因为全英文的界面+各种术语及其的不友好。许多人一进界面，立马开始懵了，我是谁，我在哪，这些都是什么玩意？ 工欲善其事，必先利其器。如果连各种功能都不懂，怎么用好这个强大的剑呢？这就好比家里放了个屠龙宝刀你却挥不动一样。所以一个一个慢慢来吧。 一 System Information 系统信息 在这一栏，你可以看到你的机器的各种信息，比如CPU型号，内存，显卡，等等。 可是对于超频/降压来说，这一栏的作用几乎为0。可以直接略过。 二 Basic Tuning 基本调整 这一栏是为了新手“简单的”超CPU倍频而设计的。操作十分简单：要多少倍频就拉多少倍频，电压依然按照机器默认电压。 然而这一栏也没有什么卵用，XTU要是就只能干这点事，那还不如卸载了得了，和点击就送的屠龙宝刀有什么区别？真正的重头戏在第三栏。 三 Advanced Tuning 进阶调整 这是控制的东西最多的一栏，可以调整电压，CPU频率，等等。 打开这一栏会有个提示，告诉你接下来的动作可能会造成硬件损坏，所以在对这一栏进行操作的时候请三思而后行。 这里只需要看全部控制，即All Control。 需要注意的是这一栏的内容会随着机器BIOS&amp;EC的开放程度变化，并不是每个机器都会有一样的内容显示。 四 Stress Test 压力测试 根据英特尔的说法，这个CPU压力测试通过运行一个“计算需求极大“的软件来测试系统的稳定性。实际就功耗来看远不如FPU 五 Benchmarking 跑分 本人从来不用这个，我更信任跑国际象棋。这个我从来没碰过。 六 Profiles 方案 这个用来存储你的降压/超频设置，要应用的时候点击Show Values，然后点Apply即可。 7.App Profiles Pairing 应用与方案绑定 这一栏很有趣，你可以指定开应用的时候用什么方案。那么如何设置呢？ 先点击Add Profile，然后双击Browse（注意要双击Browse字符而不是框框，不然没反应），选择自己要设定的App 选择这个exe，然后选择电源状态下要应用的档案（AC Power Profile），选择电池状态下要应用的档案（BatteryProfile），然后点击Pair。 关闭应用后恢复至初始状态。 总而言之还是比较有用的一个功能，但是需要注意的是Turn On之后不能再调节任何的其他选项，所以我从来不用。 ———接着是正题———— 接着是正题，如何在Advanced Tuning内做到降压。先记住两点： 1.每个CPU都有着体质的区别，可能别人同型号的CPU降了0.10v还跟没事人一样烤着fpu，自己这台机器往下探0.05v直接蓝屏了，这时候只能怪自己脸黑了。若想知道体质差距可以大到什么程度，可以百度大雕和大雷的区别。 2.降压是个很耗时间的过程，建议挑选没有作业打扰的空闲时间进行。 与CPU电压相关的项目有：Core Voltage Mode 核心电压模式，Core Voltage 核心电压，Core Voltage Offset核心电压补偿 降压需要调整的：Core Voltage Offset 核心电压补偿 首先是核心电压模式，Adaptive浮动，Static固定。在设定了Core Voltage 核心电压之后，可以对模式进行更改。那么该如何选择呢？就我个人测试而言，当设置电压为1.1v，主频3.2GHz烤P95时，第一次测试，固定电压基本上在1.17v以上，而浮动电压可以做到1.12v左右。然而在我 第二次测试电压1.02v，主频3.2Ghz烤P95，二者的电压均直逼1.15v。本着尽量少改的原则，在这里建议使用默认的Adaptive，也就是浮动电压模式。这也和NBC的选择是一致的。 核心电压不做调整，保持Default默认即可。 降压靠的是电压补偿Offset，而不是直接设置核心电压。而且直接设置核心电压是比较危险的，毕竟0.5v~2.0v的可调范围是很大的，要是碰上了熊孩子给你拉到2v，CPU直接。要知道英特尔 官方手册规定CPU电压应该在0.55v—1.52v之间。。。 那么继续到最关键的步骤，调整电压补偿Offset。 电压补偿的调整以0.005v（即5mv）为最小单位。可以通过设置改为1mv，但是这个没有太大必要，5mv已经足够。记住降压要的Offset是负值。 根据NBC的数据，一般来说6代低压处理器保持稳定的降压幅度一般在-0.06v至-0.08v之间，7代低压一般可以做到-0.07v至-0.10v。而对于标压处理器来说6代有着比7代更大的稳定降压空间。在这里我建议先以0.01v（10mv）为单位降压，先调整Offset至-0.01v，然后转至第四栏Stress Test（压力测试），勾选CPU Stress Test并选择10分钟。如果烤完了机没有任何异常（比如死机+重启/蓝屏）就继续再降0.01v。这可以使初期降压步骤节省很多时间。或者胆子大一点，直接降0.05v，也并不是不可以，但是谁知道自己的CPU体质怎么样呢？还是慢慢来吧。 在降压0.05v之后就到了比较耗时间的地方了，这时候可以以求稳为主，应该以0.005v（5mv）为单位进行降压，并且每次降压之后应该至少有20分钟的P95或者FPU的测试并且保证显卡有负载----比如GPUZ自带的渲染Render Test，或者直接甜甜圈。至于显卡负载是否必要，这纯粹是我个人的想法，因为我曾经保存一个过全核4.0GHz降压40mv的方案，这个档案通过了1个小时的FPU测试，虽然烤机频率只有3.8GHz，IACores功耗68w，但是整机仍然保持稳定。结果我有一次用着这套设置解压的时候没调回默认值，但是玩PUBG的时候表演了一波“按F跳伞一键蓝屏”的操作。。。从此阴影挥之不去。 题外话扯多了，继续。 当你到达了某个电压节点，发现烤机到了一半自己机器死机啦！蓝屏啦！自动重启啦！那么恭喜你，你完成了第一步，毕竟第一次总是会痛的嘛。每次烤机之前先记好自己降了多少电压，因为如果意外关机，XTU会恢复默认设置。把自己最后一次降压幅度减小0.01v，并且烤2个小时的机。比如最后一次降压了0.075v，蓝屏了，那就调Offset到-0.065v，然后烤机验证一下稳定性。当然这是比较稳妥的做法，如果心疼自己的机器，可以考虑上调0.015v。这绝对足够正常使用了。如果想要极限降压，应该把单位调整为1mv之后慢慢上调，还是降压0.075v的例子，先试0.074v，蓝了，再来0.073v，继续。。。只不过到最后这种在蓝屏的边缘试探的操作花费的时间太长，甚至可能要烤半天的机，而且所带来的收益不大，所以我不建议这样操作。 最后你可以点击save键保存自己的设置，起一个好听的名字（本人都是什么OC4.0 Ver2.1这种方便的名字）。这可以在Profile一栏里面找到。于是乎你就完成了一次降压。 需要注意一点XTU开机是不会自启的，更不会自动帮你降压，你要手动打开它然后去应用你的设置。我记得国外有人发帖解决了这个问题，可以做到开机就按照个人设置降压/超频，地址我忘了，你们可以找找 Turbo Boost Power Time Window（PL1 Time）短时睿频最大时间 首先我们得搞清楚这个短时睿频是个什么玩意。所谓短时睿频，就是在这个最大时间内，CPU功耗可以突破PL1但不高于PL2。一般来说7700HQ的PL2为56w，PL1为45w，PL1 Time为28s。即在28s以内，CPU的最大功耗可以达到56w，28s之后便被限制到45w。、 通过拉高这个时间可以延长短时睿频的时间，最大96s最低12s。不过对于EC锁死了PL1的机器来说，这多出来的68s并不能改变世界，而对于没有锁PL1 PL2的机器来说，这玩意也是没用的，还不如直接拉PL1。个人觉得意义不大，只能延长那些PL2不低但是PL1小的不行的机器的真男人时间 AVX Ratio AVX频率补偿 这个是控制CPU跑AVX指令集（比如浮点运算）的最大频率，对于超频党来说用处不小。比如设置x3的AVX频率补偿，倍频45x外频100MHz，那么在浮点运算的时候，CPU的主频只会到（45-3）*100=4.2GHz。因为浮点运算的发热实在太大，适当的频率补偿可以降低整机的发热，提升超频的稳定性。 总结：没有卵用，建议不动。 其实XTU也可以用来超内存，但是本人机器的BIOS并未解锁，本人对于内存超频也是一无所知，所以不讲解。似乎默认解锁了的就只有OMEN X和蓝天的那几台P系列的台U机器？不太确定。emmm 总结，XTU是一个很好的工具，不仅可以降低CPU发热，甚至可以提高性能。 建议充分使用 下面，我晒晒我自己的减压成绩。。。 p.s.大奶的E5 2997 v2不支持XTU（废话）它也用不着。。。已经改了水，散热不是问题 下面的成绩是二奶E490的 ","link":"https://qqfloatingice.github.io/post/b3/"},{"title":"发几张超级月亮","content":"Nokia808 Lumia1020 ","link":"https://qqfloatingice.github.io/post/b2/"},{"title":"【挖坟】卡片电脑挑战PC游戏","content":"发表时间2016-12-17 21:05 原发表在我已经炸了的个人博客qqfloatingice.com 近些年来卡片电脑这一概念十分流行，虽然在笔者看来也不过是ARM开发板运行个Linux套了个电脑的名头而已。实际上许多产品性能孱弱，甚至连基本办公需求都无法满足（笔者实测用树莓派1 Model B运行LibreOffice写稿，平均半小时都要奔溃一次，以至于不得不随时Ctrl+S）。然而既然卡片电脑使用的是手机、平板的处理器，同样随着近几年手机、平板处理器的快速发展，卡片电脑的性能也获得了大幅提高。我们这次的测试，就是测一测这些卡片电脑运行传统PC游戏的表现 其实可以看见不少人用这类卡片电脑自制游戏机，不过大多是用模拟器来运行一些类似FC、GBA的游戏。虽然确实是满满的游戏性，但是我们今天要挑战的是PC游戏。 容楼主再废话一句，树莓派Zero发布(u1s1现在树莓派已经到4了。。。)，只要5美元，貌似单纯的性能价格比终于能挑战我大AM2/945了？不过，如之前所说，打个字都成问题 首先上挑战的第一个游戏，DOS版仙剑奇侠传。由于只要80386处理器就能运行，似乎毫无压力。随便是用x86模拟器还是用移植版sdlpal都可以流畅运行。测试平台：树莓派1B，700MHz ARM11+512MB RAM 像DOOM、大富翁这些经典的dos游戏都是如上面所说的仙剑一样的情况，都是可以畅玩没有任何问题，这里也就不一一演示。 接下来是要挑战的第二个游戏，Tux Racer。这是845G的集成显卡也可以流畅运行。而且由于是Ubuntu/Debian的源中包含的游戏，安装过程也是十分简单，只需要在Synaptic包管理软件里面安装就可以。那么这款游戏能否在树莓派上运行呢？ 继续玩游戏的话题。如果连TuxRacer这种最基本的3D游戏都玩不了，那还有什么别的希望？仔细研究，问题还是出在对OpenGL的支持上。有没有什么支持OGL的卡片电脑呢？大家还记得老黄的Tegra么 就是这颗U，完整支持OGL4.4和DX11。然而用在小米平板上，充其量也就是给猫咪取暖罢了，因为安卓上就没有程序能去调用那些API 然而，如果是在卡片电脑上，可以安装完整的Ubuntu/Debian系统，是否证明就可以运行Tux Racer了呢？为此，笔者特意准备了一块Jetson T 不过当然啦，花1680就为了测这个是不太值，于是笔者花了280买了块故障板来练练手，修好能玩，修不好就当充值老黄信仰。 大体维修思路还是根据症状，看原理图进行修复，具体过程略，毕竟不是这次的重点。 好在问题并不严重，随便飞了几条线就好了。继续来测试，Tux Racer一次成功 第三个要挑战的和第二个差不多，也是Ubuntu/Debian原生支持的3D游戏。这款游戏名为0AD，玩法和画面很接近帝国时代3。实测GM945最低画质下帧率不足5fps。那么TK1的表现又如何呢？安装后一测，表现喜人，游戏开始时帧率稳定在37fps以上，画质为最高 但是这次，TK1也跪了，运行一段时间后会自动退出。稍微研究了下发现，MC中使用了一些编译好的运行库，也就是Windows下的DLL。编译好也就意味着这是X86或者X86_64的代码，不能在ARM下运行。不过好在这些库都开源，我们可以自己编译ARM的版本 接下来安装oracle的JRE： add-apt-repository ppa:webupd8team/java apt-get update apt-get install oracle-java8-installer 提一句，现在已经有java9可供下载，但是还是早期测试，不建议使用。java7和8应该都可以（笔者用了8），installer会安装这个版本下最新的update版本，而且可以自动识别arm/x86/x86_64 接下来来处理这些讨厌的so文件（相当于windows的dll），他们只支持x86或者x86_64 结果是出错了。看编译错误，在InfoUtilFactory.java的308行出现了调用参数不匹配的问题。解决方法就是修改代码，对症下药，让他匹配，再编译就是BUILD SUCCESS了 lwjgl虽然确实会编译一个openal的库，但是实际上这个库只是他自带的一个x86共享库打了个包而已。所以，继续自己编译...先装cmake： apt-get install cmake 对了建议开两个控制台窗口，一个给root权限一个不给，编译用没有权限那个，不然编译出来的库还得自己全部chown一下。 下载以及编译： wget http://kcat.strangesoft.net/openal-releases/openal-soft-1.15.1.tar.bz2 tar -xvjf openal-soft-1.15.1.tar.bz2 cd openal-soft-1.15.1/build/ cmake .. make 编译好后应该会生成一个libopenal.so.1.15.1 接下来把编译好的东西扔到mc里面替换掉原来的，在lwjgl/libs/linux下面有liblwjgl.so和libjinput-linux.so，复制到你mc下面有这个文件的目录（.minecraft/versions/1.8/1.8-natives），以及openal-soft-1.15.1/build下面的libopenal.so.1.15.1，重命名为libopenal.so，复制到之前的地方覆盖掉 ![]https://i.loli.net/2020/04/09/CukIQVWioDehy4F.jpg 这样只要java -jar HMCL-2.3.5.6.jar，然后按照PC的方法启动游戏就可以了！Forge也完全没有问题哦！ 结果是，在低画质下，如果站着不动，fps可以到100以上，但是一移动就会立刻掉到10以下，完全不能玩，也是说明tk1这个平台特点还是低U高显 但是要说明的是，前面讲的情况是安装了Forge，如果没有mod，游戏绝对可以流畅运行，fps基本可以稳定在100以上，最低也不会低于60，完全不会影响正常游戏 对了，实测GLSL Shader Mod不兼容，会出现GL error 0x0502，没有研究具体原因。 psp模拟器测试来了。psp模拟器也是launchpad里面自动编译的软件，并且支持armhf（hf=hard float，硬件浮点，不像intel从486开始就全面整合了浮点单元（80387），许多较为早期的arm芯片都没有整合硬件浮点）。那么来安装测试下： add-apt-repository ppa:ppsspp/stable apt-get update apt-get install ppsspp 装完就可以打开了。操作和Android、iOS上一样。 ","link":"https://qqfloatingice.github.io/post/b1/"},{"title":"水","content":"看看你们能看几分钟 ","link":"https://qqfloatingice.github.io/post/a2/"},{"title":"如何格式化损坏的TF卡","content":"方法/步骤 1.下载一个硬盘检测修复工具，下载解压出来，便可以直接运行，然后在所显示所有硬件的信息上，点USB(U盘、内存卡)，就可以在下方看到卡或U盘的芯片制造商或者芯片型号。 2.再从网上找到相对应的U盘量产网启动制作工具下载，然后使用这个相应的工具，进行格式化，就可以把内存卡或U盘救回来了。比如搜索“安国群胜Alcoru量产工具”，一般先按制造商搜索到后下载就可以了。 3.或许有的朋友U盘或内存卡里有很多好东西，不想格式化后没了，那就先用软件将数据恢复了，再进行格式化即可。恢复数据的软件用Digital ObjectRescue Pro。 4.重建分区表，修复无法格式化的tf卡。有些U盘在电脑上可以识别，但无法读写。利用Windows自带的格式化工具对其在格式化时，显示“文件系统是raw”，无法完成格式化。 MFormat、PortFree等U盘修复工具，对它也无济于事。遇到这种故障，我们该怎么办呢? 1.首先，故障设备能够被系统识别，通常为软件故障，而软件故障通常可以利用一些工具软件来修复。一些用户给能被系统识别而无法格式化的TF卡判了死刑，实在可惜。 2.我们知道，当硬盘的分区表损坏时，也无法完成格式化。遇到这种情况时，可以利用Windows自带的分区工具Fdisk，重建分区表。解决硬盘故障的这种思路同样可以用在U盘上，具体方法略有不同。 Step 1：输入“win+R” 点击窗口“磁盘管理”，屏幕出现当前系统中所有存储设备的信息。 Step2：光标指向待修复的TF卡，点击鼠标右键，选择“新建分区”，再选择“FAT32”，系统将提示分区创建成功。 Step 3：对TF卡进行格式化。 通过上述步骤，TF卡即可得以修复。 ","link":"https://qqfloatingice.github.io/post/a1/"},{"title":"【转】玩转你的 KaiOS 手机 【基础篇】 - Nokia 8110 4G 篇","content":"来自KaiIce的@失去时间の魔王 （部份内容来自清水博客） 版权所有 ©2020 KaiIce Blog ©2020 Hope Studio ©清水博客 KaiOS 交流群 写作日期：2020-04-01（不要觉得这个日期可疑，真的只是凑巧） 如何玩转你手头上的手机？ 安卓用户会说：刷机 苹果用户会说：越狱 塞班用户会说：开发 App 而 KaiOS 用户会说： 这不是笑话，是真的。KaiOS 没有较高的自由度，只可以进行“越狱”；KaiOS 开发 App 比这三者简单；KaiOS 也可以刷机，甚至底层 OTA 更新包证书签名还是走的 Android 6.0.1 的签名！ 那，我们开始吧。 众所周知，开发网页应用至少比开发可编译应用简单的多，而这条定理 KaiOS 则是利用得淋漓尽致。 为什么？ 如果你手头上有一个 KaiOS 应用安装包，并且你是开发过网页的，就先把它解压缩。解压缩之后呢，你会发现你熟悉的 index.html ......然后你深入包里的其他文件夹，你会发现你那亲切又好用的 —— JavaScript 和专门搞“装修”的 —— 层叠样式表（CSS）...... 这下知道奥妙了吧，看到这儿的朋友们可能会发飙：“我 TM 花了几百原来买的是个浏览器！！！” 没错，就只是个浏览器。 但这个浏览器可以听歌看图百度微博玩游戏等等等等，而且比其他的便宜不少。 然后你的表现就概括为一个词： 真香！ 准备 一台搭载 KaiOS 的 手机 如 Nokia 8110 4G 或 Nokia 2720 Filp 或 Nokia 800 Tough 一台电脑（Windows 或 Linux） ADB 工具包 或 思乐冰工具包（Powered By 清水 @QQ思乐冰）（在 KaiHub 或 清水群中下载） GerdaOS 有 坐和放宽 的 耐心 有不怕自己手机报废（开个玩笑）的决心 OmniSD 安装 肯定有人问，我装这个应用程序干嘛，我可以十分务实的告诉你，如果你不装的话，你买这 KaiOS 手机就完全没意义了。为什么？这个应用程序可以安装应用商店外的 App，如果你不装的话，就只能用应用商店那微薄的九个中文（如果思乐冰的 KaiAuth 申请成功的话算 10 个）应用，到时候只能望着英、法、德、俄语而暗自垂泪。 可是如果你装了的话，你就可以安装 KaiHub 和 KaiOS 资源下载站 的所有 App，有便签、网易云音乐、bilibili、QQ邮箱等等等等。然后你的表现再次归结为一个词： 真香！ 好了，现在不废话了，我们开始吧。 首先，打开思乐冰一键 OmniSD 工具包，你就会看到如下界面： （前提：安装 ADB 驱动） 然后跟着文字提示往下走，你就安装完成了。 Q：OmniSD 如何安装 App？ A：把安装包放到内存卡的Apps文件夹中。（没有的话新建一个）然后重新扫描，找到你想安装的包，按下中间键就完美了。 Q：……没问题了。 A：很好。 越狱 说到越狱，开发者们总会想起那著名的“长按关机键和 HOME 键进入 Recovery 模式”。没错，针对 KaiOS 手机，也有进入 Recovery 模式的方法。 方法一 首先，在手机上拨打(* # * # 3 3 2 8 4 #* # *),然后任务栏就出现了一只小甲虫（即调试模式），然后用 ADB 工具包输入ADB REBOOT RECOVERY，就成功进入恢复模式。 方法二 先关机，然后长按 上方向键 和 电源键，感到手机震动后松开。 —————————— 学完以上方法后，然后从群文件里下载 GerdaOS 卡刷包，再把卡刷包复制到一个拥有 4GB 以上容量的内存卡中，装上手机，使用临时root并通过通过shell降级recovery（方法） 此步骤执行之前，请确保recovery镜像已经存放在存储卡根目录下并重命名为recovery.img。 在终端/命令提示符中逐行复制： adb shell busybox dd if=/dev/block/bootdevice/by-name/recovery of=/sdcard/recovery-backup.img bs=2048 busybox dd if=/sdcard/recovery.img of=/dev/block/bootdevice/by-name/recovery mount -o remount,rw /system echo '#!/system/bin/sh' &gt; /system/bin/install-recovery.sh echo 'exit 0' &gt;&gt; /system/bin/install-recovery.sh chown root:root /system/bin/install-recovery.sh chmod 750 /system/bin/install-recovery.sh sync mount -o remount,ro /system exit reboot 然后后使用刚才教过的方法进入 Recovery 模式。 开始越狱 进入 Recovery 模式后，你会发现一大堆英文，下面给专业英文困难户讲解一下。 （方向键选择、电源键确定） KaiOS Recovery（ KaiOS 恢复模式） Use navigation/power keys （使用 方向键/电源键 进行操控） Reboot system now （立刻重启） Apply update from ADB （从安卓调试桥（即 ADB 工具包）复制数据来刷机） Apply update from SD card （从 SD 卡 复制数据 来刷机） Wipe data / factory reset （清除所有数据并恢复工厂设置） Wipe cache partition （清除缓存分区） Mount /system （装载系统分区） View recovery logs （查看恢复日志） Power off （关机） 先选择备份原有操作系统 重启进入recovery（方法上面已经提到，这里不再赘述） 选择Mount /system（上下键选择，返回键确认） 选择Apply update from SD card 选择dumpall.zip 稍等一会 在recovery重新弹出菜单后选择reboot system now重启至系统。 至此，你的当前系统已经备份到存储卡的DUMPS文件夹下。 然后转载系统 重启进入recovery 选择Mount /system 选择Apply update from SD card 选择gerda-install-702d409.zip 稍等一会，等待recovery菜单重新弹出 选择Wipe data/factory reset双清 选Yes 选择reboot system now重启至系统。 至此，如果开机界面变为一只Linux企鹅和GerdaOS图标，即为刷机成功。您可以体验您的新系统了。您可以通过自带 的“GerdaPkg”安装第三方软件了。 文件下载（来源于清水博客） 刷机包 gerda-install-730c6b1.zip 链接:https://pan.baidu.com/s/1WyGQ1E-AQFbAar4Wg3rRGQ 提取码: wpsp 其他文件： https://www.lanzous.com/b623501/ 密码：2xra 常见问题 Q：如何截屏？ A：手机滑盖滑至半关闭状态，按电源键。 Q：电源键不管用了怎么办？ A：GerdaOS修改了电源键的用途，滑盖全开时按电源键是后台运行，滑盖全开时长按会弹出最近任务，滑盖半开时按 电源键是截屏，只有滑盖关闭时才和以前一样，短按息屏亮屏，长按关机。 Q：OTA更新后手机不能用了怎么办？ A：上面就说过了不能OTA更新。重刷一遍，不行找售后。我不承担任何责任。 Q：贪吃蛇没了怎么办？ A：链接: https://pan.baidu.com/s/1s9o98f-sJ4yPO9_LnIny5g 提取码: 4msi ","link":"https://qqfloatingice.github.io/post/a/"},{"title":"关于gitalk中评论报错的解决方案","content":"首先，找到这个文件夹 C:\\Users\\你电脑的用户名\\Documents\\Gridea\\themes\\你正在使用的主题\\templates\\_blocks} 打开scripts.EJS将ID ： 这一行改为 id: decodeURI(&quot;{{ page.url }}&quot;), // Ensure uniqueness and length less than 50 保存即可 但是这又引起了新的bug。。。。每篇文章都共用一个评论区。。。 ","link":"https://qqfloatingice.github.io/post/b/"},{"title":"【恶臭系列】8110与飞利浦E289（69元）对比","content":"以下是飞利浦E289测评【转自】贴吧 看起来平平无奇的飞利浦箱说全，闲鱼69收入 非常的中规中矩 翻过来一看，果然深圳出品，1700mah的电池，搭配2.4qvga的分辨率在老人机中也是非常中规中矩的存在（诺基亚：你说什么？但是细心的人可以看出了点不对的东西？ 首先进入眼帘的是一台非常没有特色的山寨机样式毫无设计美感的老人机，键盘设计偏大一看就是为了手指不便的年轻人设计的（没错包括我这种从小就不喜欢九宫格，第一次接触到全键盘后感受到新世界的90后。 拿开手机后，里面非常的简陋，只有一个充电器，和micro usb的充电线一条，没有超级大礼包 我们来仔细看一下输出功率 5V 0.5a的输出功率。。。。emmm 四分之一卢，考虑到只要69我也不说什么了 但是只看直面数据是不对的，让我们的电流表来测测这个充电器的实际功率 WTF??? 4.1W的充电功率。我炸了呀，我看了看我手里7P的原装充电器（垃圾苹果 这年头充电器都能反向虚标的嘛？ 现在让我们开个机吧 插电，开机！ 啊，屏幕亮了 先让我们看看它能干什么！ WTF！！！它甚至可以上B站，不但可以上b站 它还能点开来看 看看弹幕美滋滋 甚至还能让你倾听人民的声音 系统为安卓8.1 更不可思议下的是，这是什么？这是时下最为先进的3.5mm耳机接口嘛？如今在这个时代的浪潮下，还愿意使用高贵富态的3.5mm接口实在是难以置信，不愧是皇家飞利浦，出手不凡。 及其先进的可更换可插拔的电池设计 既然拆开了电池就来看一下内部结构，标准的双卡双待的设计？咦居然还是用了小卡的设计，这是我之前没想到的，之前常见的老人机还是以大sim卡的设计在里面，而且还具备了2sim卡+1tf卡的及其先进的设计实在是太令人感觉到震惊了。（国际大厂们：喵喵喵？ 来，我们把这个小飞利浦的里面赛的满满的一点都不能放过 顺便看看上一台不支持电信卡而惨遭我抛弃的诺基亚小兄弟。 甚至可以来一个高德地图! 对比本人的8110 .。。。 除了外观，应该什么都打不过吧。。。 不过有外观和情怀在就够了 虚假.jpg ","link":"https://qqfloatingice.github.io/post/c/"},{"title":"ubuntu花屏的解决办法","content":"原因： 是linux-kernel的kms引起的2.6.32-26里面存在。 解决办法： 在终端里输入： sudo vi /etc/modprobe.d/radeon-kms.conf 在编辑器里输入： options radeon modeset=0 保存 然后重新启动机器。 ","link":"https://qqfloatingice.github.io/post/d/"},{"title":"【转】修复8110的按键速度","content":"tags: 本教程来自Banana-Hackers论坛，由Sylvain D提供原教程，Vivek改进，KaiOSLab翻译。 8110的一个经典问题是打字速度太过诡异，这里是解决(缓解)这个问题的方法 ***注意***在做如下步骤前请root你的手机，软件点此，教程点此——来自清水博客 1.从system获得键盘应用的复制 adb pull /system/b2g/webapps/keyboard.gaiamobile.org ​ 注意！经过测试，win10或者其他不明原因，执行上面的命令后，adb文件夹下不会出现keyboard.gaiamobile.org文件夹，所以会导致之后的命令失败，可以按时间顺序筛选出pull下来的文件，将他们放在新建的keyboard.gaiamobile.org文件夹即可提示点此来自——此店不售此书的博客。 2.打开application.zip 打开里面的/js/keypad.js（不要使用记事本，不需要解压） 3.找到这一部分： Keypad.prototype.LONGPRESS_INTERVAL=1000; Keypad.prototype.IDLE_INTERVAL=1000; （VSCode可以按Ctrl+F查找） 改为： Keypad.prototype.LONGPRESS_INTERVAL=500; Keypad.prototype.IDLE_INTERVAL=400; 4.在ADB命令行中执行 adb push keyboard.gaiamobile.org /data/local/webapps 5.使用下面的命令获得***webapps.json*** adb pull /data/local/webapps/webapps.json 6.打开ADB文件夹下的webapps.json 找到这一行： &quot;basePath&quot;: &quot;/system/b2g/webapps&quot;, 改成： &quot;basePath&quot;: &quot;/data/local/webapps&quot;, 7.在ADB中逐行运行： adb push webapps.json /data/local/webapps/ adb reboot 8.重启后按键问题就会得到缓解 57步的作用：防止更改system而引起的翻车恢复不了，执行57步后，所有的更改将会在出厂设置后恢复，之前执行过的可以不执行5~7步 ————转自QQ old ice 的KaiOSlab ","link":"https://qqfloatingice.github.io/post/f/"},{"title":"kaios百度翻译开发笔记","content":"有于本人英语特别渣，所以特别需要一个翻译来解决问题，又因为最近的网课可以摸鱼，所以在kaios开发了给简陋的翻译0.0.1（目前更新一直鸽着）。。。。 所以有人看到这个贴子的话（我知道这个小破站基本没人来。。。）请把它进行改进 首先，请申请百度翻译API 得到key和ID这个也有用 然后就构建html文件，要求可视化的可用DW（详见友情链接中的神奇的软件站）不要求的随便 这里给个参考代码 &lt;!doctype html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Translate&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;SRC&quot;&gt; &lt;textarea id=&quot;srcText&quot; name=&quot;srcText &quot; style=&quot;width:500px; height:120px;&quot;&gt; &lt;/textarea&gt; &lt;button id=&quot;Click&quot; name=&quot;Click&quot;&gt;Translate&lt;/button&gt; &lt;/div&gt; &lt;br /&gt; &lt;hr /&gt; &lt;div id=&quot;DST&quot;&gt; &lt;textarea id=&quot;dstText&quot; name=&quot;dstText&quot; style=&quot;width:500px; height:120px;&quot;&gt; &lt;/textarea&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src=&quot;jquery-1.8.2.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(&quot;#Click&quot;).click(function (){ var contents = $(&quot;#srcText&quot;).val() ; alert( contents) ; $.ajax({ type:&quot;get&quot;, async:false, //must be synchronized url:&quot;http://openapi.baidu.com/public/2.0/bmt/translate&quot;, dataType:&quot;jsonp&quot;, data: { from: &quot;翻译的源语言&quot;, //language choose to: &quot;翻译成的语言&quot;, client_id: 这个地方输入你自己在百度开源申请的API 的 KEY, //baidu api key q: contents }, success:function(json , status){ //alert(&quot;here is the status :&quot;+status) ; $(&quot;#dstText&quot;).empty() ; for ( var i = 0 ; i &lt; json.trans_result.length ; i++ ) { $(&quot;#dstText&quot;).append( json.trans_result[i].dst +&quot; &lt;br /&gt;&quot;) ; } // alert(json.trans_result[0].dst +&quot; &lt;br /&gt; &quot;+json.trans_result[0].src) ; }, error:function(){ alert('Fail to translate with baidu API!'); } }); }) ; &lt;/script&gt; &lt;/html&gt; ","link":"https://qqfloatingice.github.io/post/p/"},{"title":"让老旧平板焕发新生","content":"由于本人苦逼经常更换住址，所以发现原先的第二显示屏不便于携带使用。 所以迫切的需要一台便携的第二屏配合虚拟机使用，然而又因为快递还没恢复，于是我便把邪恶的目光看向了久经沙场的ipad4，我目前的方案是，在虚拟机上安装某远控软件现在成品是这样的。 p.s.E490是真的弱鸡，虚拟机只能带一个 随着一段时间的使用，目前我的体验是这样的，最好配合鼠标，键盘使用。虽然可以触控但是体验不是很好，并且建议轻度使用。要生产力的话，强烈推荐键盘鼠标。 ","link":"https://qqfloatingice.github.io/post/q/"},{"title":"二奶机 thinkpad E490的简要测评","content":"由于蓝天P570WM过于笨重，再加上功耗和续航还有巨大的电源适配器，基本上就是台式机的命，再加上原先的ideapadU410的性能和续航问题，我决定重新买一台二奶。 在TP专卖店JS的吹捧下，在加上我还有一台17年的X1翻转本，我买下了E490。 关于外观，我就不多说了。虽然这一代的E系列虽然好了很多，但是还是有一些槽点的，我就不一一吐槽了。 后来，我在使用的过程中我发现联想对该机的调教过于保守，使性能不能完全发挥，于是乎就下了Intel(R) Extreme Tuning Utility去掉了功耗墙，又通过降电压，跑满睿频,使CPU-Z的跑分上了2000，超过I5 7600！ 显卡方面，对于没有什么游戏需求的我，RX552海星，（据说有人拿它吃过鸡）。。。 键盘方面，比我蓝天的键盘好多了，但是没有X1舒服（玄学问题）。。。个人觉得比机械打字舒服。。。 屏幕。。。。。。。最大的槽点。。。。不说了 总之，作为一台备用的二奶E490够了（至少性能比2017X1)强。。。。但是画图还是要X1.。。。 ","link":"https://qqfloatingice.github.io/post/a3/"},{"title":"【教程】DIY一块msata固态硬盘（来自我的原网站）","content":"陪伴7年的老本U410上面的msata固态硬盘挂了，症状是开机卡在LOGO界面，按F2进bios需要等5分钟，bios里不识别…由于主硬盘位装着机械不能拔，所以自己DIY一块msata固态硬盘，所需材料和工具如下： 1、2246xt msata主控板一张； 2、东芝原厂正片mlc颗粒两颗（单颗64g）； 3、msata转sata转接板一张； 4、sata转usb转接板一张（用于开卡）； 5、热风枪、助焊剂、镊子、洗板水等； 6、不太残的手一双 这块主控板采用的是慧荣2246xt方案，SATA3接口，支持4贴4通共16CE，支持BGA132和BGA152颗粒，单贴和双贴优先主控面。 废话不多说，先来贴第一颗。涂点助焊剂，颗粒摆好位置，因为颗粒是BGA132所以两边要各留出一排脚位。由于主控板用的是高温焊锡，一开始我习惯风枪温度300，吹了半天焊锡都没融化直接升温到320吹15秒就搞定了。 再来第二颗（如果只单贴一颗闪存，这个主控板要先从主控面接口短的这边贴），方法和刚才一样320度直接吹，20秒搞定。 等冷却后检查一下，看起来焊的还不错 固态和转接板合体，固态还是屁股朝上的姿势。 用镊子短接主控板的rom两点（镊子大力捅进去），连接sata转us b转接卡，连接电脑准备固态开卡。 所用的开卡工具为2246xt 0213H版本，先点击右边的Scan Drive搜寻主控，正确识别后Port1里能看到主控名字。 进入Parameter选项卡修改设定，先点Edit Config修改，密码为两个空格，再点击Auto自动识别闪存颗粒（如果工具有该颗粒id会自动识别，如果没有就需要自己手动添加），可以自己修改固态的id，磁盘大小选择自动，然后点Save Config保存。 回到Test选项卡，直接点Start开始开卡，等待一分钟图中工具报错Run ISP Fail(50)，其实已经开卡成功了。 关掉开卡工具，进入Windows10磁盘管理，看，已经正确识别了 117.98GB可用容量 测速测速，看看这块自己diy出来的固态速度到底怎么样。由于Y460只有sata 2的接口，只能在台式新平台上跑分了。 这个分数是什么水平呀对比使用多年的SanDisk 加强版120g速度，两块大号U盘 在笔记本上开机识别正常，系统安装顺利。Win7下sata2的跑分如图，这速度不愧是大号u盘 ","link":"https://qqfloatingice.github.io/post/x/"}]}